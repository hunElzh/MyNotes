## 服务端与客户端

微服务中的服务端就是提供接口的那一端，微服务中的客户端就是调用接口的那一端



## 注册中心Eureka

> Eureka为一个独立的服务，由于它可集群的特性，所以它既是服务的提供方，又是服务的消费方；并且它同时作用于消费方和服务方

zookeeper也是一种注册中心

### 基本架构

![zzzzzzfsd9ba9df76qry9i7k](E:\Study\Mynotes\MyNotes\img\zzzzzzfsd9ba9df76qry9i7k.png)

- Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址
- 服务提供者：启动后想Eureka注册自己的信息（地址，提供什么服务）
- 客户端消费者：想Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新
- 心跳：提供者定期通过http方式向Eureka刷新自己的状态



### 相关配置

1. euraka

   ~~~ yml
   # 配置服务端口
   server: 
   	port: port
   # 将当前eureka服务注册进对应服务中（此时eureka本身被当成一个注册者）
   eureka:
   	client:
   		server-url:
   			defaultZone: http://ip:port/eureka
   # 配置服务名称
   spring:
   	application:
   		name: appname
   ~~~

2. 服务提供方

   引依赖、加注解、改配置。完成即可将服务端注册至注册中心

3. 服务消费方

   引依赖、加注解、该配置。完成即可从注册中心中获取服务

**Eureka本身也是一个独立的服务，注册中心是该服务的核心功能**





## 负载均衡Ribbon

> Ribbon作用于服务的消费方

消费者要调用服务者的方法，首先得知道是哪个服务者提供的服务，又由于一个服务可能是一个集群环境，此时消费者就需要通过负载均衡算法来决定获取那个服务者提供的方法。Ribbon就提供了很多负载均衡算法。

负载均衡作用于消费者，作用域消费者从注册中心中获取其他服务的方法时生效



## 熔断Hystrix

> Hystrix作用于服务的消费方

### 服务雪崩

客户端发起一个请求，当该请求请求的服务中有一个挂掉了，这个请求就会一直阻塞，挂在服务器的内存中，当这种请求发送次数逐渐增多，这种无法处理的请求就会将服务器资源消耗殆尽。导致无法响应其他可成功响应的请求。

### Hystrix解决雪崩问题的两种方法

#### 线程隔离和服务降级

- 线程隔离：使用线程池为服务器中的每一个服务都设定固定大小的线程，当一个服务挂了，最终也只会影响那个服务所处的线程，不会影响到服务器所有的线程。并在此基础上设置一个timeout，当服务挂起过长时间返回给客户端消息。
- 服务降级：当服务线程池排满之后，就会引起当前服务降级。

#### 服务熔断

当服务出现问题，通过断路的方式，将后续请求直接拒绝掉。一段时间之后允许部分请求通过，如果调用成功则回到熔断闭合状态，否则熔断状态继续为打开。

熔断机的三个状态

- Closed：关闭状态，所有请求都可以正常访问
- Open：打开状态