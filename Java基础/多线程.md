## 线程的状态转换

![WUF6TJBSTECPQC6P6IE](..\img\WUF6TJBSTECPQC6P6IE.png)

- 新建（New）：创建后尚未启动

- 可运行（Runnable）：可能正在运行，也可能在等待CPU的时间片。包含操作系统中的Running和Ready

- 阻塞（Blocked）：线程阻塞，当前线程停止运行。由`排他锁`引起，如果其线程释放了锁就会结束此状态

- 有期限等待（Time Waiting）：线程进入等待状态，当设定时间一到，线程继续执行

  ![5S0HV23V0YW6$2JZRA](..\img\5S0HV23V0YW6$2JZRA.png)

- 无期限等待（Waiting）：与有期限等待对应，只有通过特定的退出方法才可继续执行线程

  ![L64QLMMQ1MLOCWR8F](E:\Java\GitRepository\MyNotes\img\L64QLMMQ1MLOCWR8F.png)

- 终止（Terminated）：线程运行结束或者运行过程中产生了异常

## 创建线程的三种方法

- 继承Thread
- 实现Callable/Runnable接口

那现在我们来观察一下下列这仨创建线程的方法：

```java
class ExtendThread extends Thread{
    @Override
    public void run() {
        System.out.println(currentThread().getName()+" start");
    }
}

class ImpRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println("runnable start");
    }
}

class ImpCallable implements Callable{
    @Override
    public Object call() throws Exception {
        System.out.println("callable start");
        return "success";
    }
}

public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExtendThread thread1 = new ExtendThread();
        ImpRunnable runnable1 = new ImpRunnable();
        ImpCallable callable1 = new ImpCallable();

        //执行Thread线程
        thread1.start();
		
        //执行Runnable线程
        Thread thread2 = new Thread(runnable1);
        thread2.start();

        //执行Callable线程
        FutureTask futureTask1 = new FutureTask(callable1);
        Thread thread3 = new Thread(futureTask1);
        thread3.start();
        System.out.println(futureTask1.get());
    }
}
```

通过实现接口创建线程的好处

1. 实现接口之后还可以继承其他类，而继承Thread创建接口对象的话就无法继承其他类
2. 一个线程类只需要重写Thread的run方法即可，如果单独继承Thread的话开销过大



## 基础线程机制

### 线程池的创建

>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

Java中线程池的创建主要是通过Executors类来实现的。接下来通过例子简单看一下线程池的使用

~~~ java
public class Test extends Thread{

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 5; i++) {
            //线程池执行任务
            executorService.execute(new Test());
        }
        executorService.shutdown();
    }

    @Override
    public void run() {
        System.out.println(currentThread().getName()+"execute");
    }
}
~~~

首先，我们可以通过Executors的方法来创建ExecutorService(线程池)对象。Executor创建线程池的方法主要有以下几种

1. newCachedThreadPool()：一个任务创建一个线程
2. newFixedThreadPool(int nThreads)：线程池中的任务只能使用固定大小的线程nThreads
3. newSingleThreadExecutor()：相当于newFixedThreadPool(1)，即该线程池中的任务只能使用一个线程

然后调用executorService.execute(Thread对象)执行对应线程

最后调用executorService.shutdown()来关闭线程 



### 守护线程(应该不重要吧)

> 守护线程是一个程序运行时，在后台提供服务的线程。守护线程不是程序不可或缺的部分，因此只需要简单的了解

当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。我们使用setDaemon()方法将一个线程设置为守护线程。

~~~ java
public class Test extends Thread{

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Test test = new Test();
        test.setDaemon(true);
    }

    @Override
    public void run() {
        System.out.println(currentThread().getName()+"execute");
    }
}
~~~

从上面的例子中我们将继承Thread类的Test类设置了一个守护线程

Java中main方法就是一个非守护线程，当main执行完毕之后，main中的守护线程全都会被杀死



## 线程中断

### 使用interrupt()方法调用线程中断

> 当线程中有抛出InterruptedException这个异常时，调用interrupt()方法即可中断线程

```java
public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    System.out.println(Thread.currentThread().getName() + " start");
                    Thread.sleep(2000);
                    System.out.println(Thread.currentThread().getName() + " running");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        thread.start();
        thread.interrupt();
        System.out.println("Main Run");
    }
}
```

![BTUKJ0KXSB3IHUR3A](..\img\BTUKJ0KXSB3IHUR3A.png)

线程的interrupt()方法是由Thread.sleep()方法引起的，当调用了当前线程thread.interrupt()方法后就会抛出InterruptedException，从而提前结束当前线程。正如上图，若没有调用interrupt()方法，那么线程将不会中断。

需要注意的时，interrupt()方法只能中断处于**阻塞、期限等待或者无限期等待**状态的线程，如果线程处于**I/O阻塞和synchronized锁阻塞**的话，将无法被中断。

但如果，一个线程进入了死循环，并且在其中没有抛异常的话，interrupt() 方法将毫无用处，这种情况要如何才能中断当前线程呢？



### 使用interrupted()方法中断线程

如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。

但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 ture。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。

~~~ java
public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                //在无限循环中调用interrupted()方法，当在外部调用interrupt()方法后，
                while (true) {
                    //interrupted()方法像是一个标记方法，当在外部调用interrupt()方法后，Thread.interrupt()方法返回ture，循环结束
                    if (Thread.interrupted()) {
                        break;
                    }
                }
                System.out.println("thread end");
            }
        });

        thread.start();
        thread.interrupt();
    }
}
~~~

![zzzzzzzz6s7d97as9](E:\Java\GitRepository\MyNotes\img\zzzzzzzz6s7d97as9.png)

执行上面的程序，运行结果如上图所示，线程中的死循环被 Thread.interrupted() 打破



### 使用Executor中断线程

> Executor是用来创建线程池的，它的shutdownNow()方法可以中断当前所有线程。若用此方法来中断线程，那么线程池中的所有线程都将被影响。

~~~ java
public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //创建线程池
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    System.out.println("before interrupt");
                    Thread.sleep(2000);
                    System.out.println("after interrupt");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        //shutdown()方法相当于对线程池中的所有线程执行了一遍interrupt()方法
        executorService.shutdownNow();
    }
}
~~~

调用executor Service.shutdownNow()方法相当于对线程池中的每一个线程都调用 interrupt() 方法。

如果指向中断Executor中的一个线程，可以通过 submit() 方法来提交一个线程，他会返回一个 Future<?> 对象，通过调用该对象的 cancel(true) 方法并传递参数true即可 中断线程。



## 互斥同步

> 互斥同步是指，程序代码中的某一段代码，会被加“锁”，当某个”锁“中的代码调用到线程共享的资源时，其他线程此时就无法访问当前这段共享代码，知道这个“锁”被释放

Java提供了两种锁机制来控制多个**线程对共享资源的互斥访问**

- 第一个是 JVM 实现的 synchronized
- 而另一个是 JDK 实现的 ReentranLock



### synchronized

在synchronized关键字修饰的代码作用域中，线程同步

#### 同步一个代码块

~~~ java
synchronized(对象) {
    //...
}
~~~

如果要同步代码块，那么不同的线程传入的这个对象必须是同一个对象。如果同步代码块前传入的对象不是同一个对象的话，就不会进行同步。正因为这个机制，我们可以设置一个全局的对象，以保证静态代码块的同步

（为什么传入不同的对象就不会同步呢？）

- 使用synchronize同步代码块实现线程同步

  ```java
  class SynchronizedExample {
      public void fun1() {
          //同步一个代码块时，需要传入同一个对象，无法成功同步
          synchronized (Test.class) {
              for (int i = 0; i < 10; i++) {
                  System.out.print(i+" ");
              }
          }
      }
  }
  
  public class Test {
      public static void main(String[] args){
          SynchronizedExample syn1 = new SynchronizedExample();
          //Executors.newCachedThreadPool()，每传入一个runnable实例就会创建一个线程
          ExecutorService executorService = Executors.newCachedThreadPool();
          //execute(Runnable)，我们在这里面传入的lambda表达式其实就是重写了Runnable.run()方法罢了
          executorService.execute(() -> syn1.fun1());
          executorService.execute(() -> syn1.fun1());
          executorService.shutdown();
      }
  }
  ```

  ![zzzzz979r379327894](E:\Java\GitRepository\MyNotes\img\zzzzz979r379327894.png)

- 当传入不同对象时线程执行异步

  ```java
  class SynchronizedExample {
      public void fun1() {
          //同步一个代码块时，需要传入同一个对象，无法成功同步
          synchronized (Test.class) {
              for (int i = 0; i < 10; i++) {
                  System.out.print(i+" ");
              }
          }
      }
  }
  
  public class Test {
      public static void main(String[] args){
          SynchronizedExample syn1 = new SynchronizedExample();
          SynchronizedExample syn2 = new SynchronizedExample();
          //Executors.newCachedThreadPool()，每传入一个runnable实例就会创建一个线程
          ExecutorService executorService = Executors.newCachedThreadPool();
          //这里向Runnable中传入实力类的方法，估摸着jdk把这个方法通过特定方式写入到run()方法中去了
          executorService.execute(() -> syn1.fun1());
          executorService.execute(() -> syn2.fun1());
          executorService.shutdown();
      }
  }
  ```

  ![zzzzs9d7f923894v7](E:\Java\GitRepository\MyNotes\img\zzzzs9d7f923894v7.png)
  
  
  
- 只要是相同对象，就都能同步

  ~~~ java
  public class Test {
  
      //定义一个全局的对象，保证代码块中线程同步
      static Object object = new Object();
  
      static class SynchronizedExample {
          public void fun1() {
              synchronized(object) {
                  for (int i = 0; i < 10; i++) {
                      System.out.print(i+" ");
                  }
              }
          }
      }
  
      public static void main(String[] args){
          SynchronizedExample syn1 = new SynchronizedExample();
          SynchronizedExample syn2 = new SynchronizedExample();
          ExecutorService executorService = Executors.newCachedThreadPool();
          executorService.execute(() -> syn1.fun1());
          executorService.execute(() -> syn2.fun1());
          executorService.shutdown();
      }
  }
  ~~~

  

#### 同步一个方法

~~~ java
public synchronized void fun() {
    //...
}
~~~

它和同步代码块一样，作用于同一个对象。

#### 同步一个类

~~~ java
public void fun() {
    synchronized (Test.class) {
        //...
    }
}
~~~

传入一个类作为参数，不论该类实例化多少个对象，它们同步区块中的内容一定同步。

~~~ java
class SynchronizedExample {
    public void fun1() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i < 10; i++) {
                System.out.print(i+" ");
            }
        }
    }
}

public class Test {
    public static void main(String[] args){
        SynchronizedExample syn1 = new SynchronizedExample();
        SynchronizedExample syn2 = new SynchronizedExample();
        ExecutorService executorService = Executors.newCachedThreadPool();
        //由于同步是针对SynchronizedExample这个类的，所以
        executorService.execute(() -> syn1.fun1());
        executorService.execute(() -> syn2.fun1());
        executorService.shutdown();
    }
}
~~~

![zzzzzzzasd97wef616a78gagsd](..\img\zzzzzzzasd97wef616a78gagsd.png)

#### 同步一个静态方法

~~~ JAVA
public synchronized static void fun() {
    //...
}
~~~

作用于整个类，即不用传入同一个对象实例



### ReentrantLock

>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。

它是通过Lock实例化对象的方法来对代码区块进行加锁操作的

#### ReentrantLock的基本使用

~~~ java
public class Test {
    Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i < 10; i++) {
                System.out.println(i + " ");
            }
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        Test test = new Test();
        ExecutorService executorService = Executors.newCachedThreadPool();
        //ReentrantLock是通过Lock接口实例来实现死锁的，不论线程对象是否一致，线程一定同步
        executorService.execute(() -> test.func());
        executorService.execute(() -> test.func());
        //executorService.execute(() -> test1.func());
        //executorService.execute(() -> test2.func()); 假设有test1和test2，这样线程也是同步的
    }
}
~~~

![zzzzzzzasd97wef616a78gagsd](..\img\zzzzzzzasd97wef616a78gagsd.png)



### synchronized和ReentranLock的区别

1. **锁的实现**：synchronized 是 JVM 实现的；ReentranLock 是 JDK 实现的
2. **性能**：synchronized 与 ReentranLock 性能大致相同
3. **等待可中断**：等待可中断是指，当**持有锁的线程**长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentranLock 可以中断；synchronized不行
4. **公平锁**：公平锁是指多个线程在等待同一个锁是，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的；ReentranLock 默认情况下也是非公平的，但它也可以是公平的。
5. **锁绑定多个条件**：一个 ReentranLock 可以同时绑定多个 Conditon 对象，Conditon 对象在后续会介绍到



### 使用选择

如果没有要用 ReentranLock 的高级功能的需求的话，就用 synchronized 吧。因为 synchronized 是JVM 实现的一种锁机制，JVM 原生就支持它，而 ReentranLock 不是所有的 JDK 版本都支持。并且 synchronized 不用担心因为忘记释放锁而导致的死锁问题，这些 JVM 都帮我们搞定了。



## 线程之间的协作

### join()

假设由线程 A、B，此时的场景是我们想让线程 A 优先于线程 B 执行，并且线程 B 要比线程 A 先启动。如果需求是这样的话，那我们加锁也没用了，此时想要实现这个功能，就只能用这一小节介绍的方法 **join()**。

~~~ java
public class Test {
    private class A extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                System.out.println("Thread A run");
            }
        }
    }

    //在 线程B 中传入对应 线程A 的实例，直接new的话是创建一个新的线程A实例。
    private class B extends Thread {
        private A a;

        B(A a) {
            this.a = a;
        }

        @Override
        public void run() {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            for (int i = 0; i < 10; i++) {
                System.out.println("Thread B run");
            }
        }
    }

    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }

    public static void main(String[] args) {
        Test test = new Test();
        test.test();
    }
}
~~~

![z49a7zzzzd48fa9](..\img\z49a7zzzzd48fa9.png)

从运行结果中我们可以看出，线程A 一致是在 线程B 之前运行的。

**注意例子中的 线程A 是通过参数的方式传递给 线程B的**



### wait() notify() notifyAll()

> 调用 wait() 使得线程等待某个条件满足，当条件满足前，这个线程就会被挂起。当其他线程的运行使得这个条件满足时，其它线程还会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。

这仨方法属于Ojbect，而不属于Thread，至于为什么，目前我还不太清楚。

这仨方法只能用在同步控制块（synchronized或者ReentranLock）中，否则运行时会抛出  IllegalMonitorStateException。

**使用 wait() 的线程在挂起期间，线程会释放锁**，否则其他线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，最终死锁。

```java
public class Test {
    public synchronized void before() {
        System.out.println("notify thread in wait");
        notifyAll();  //调用notifyAll()方法，唤醒所有挂起的线程
    }

    public synchronized void after() {
        try {
            wait();  //调用wait()方法，当前线程挂起，需要其他线程来将其唤醒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("wait to be notified");
    }

    public static void main(String[] args) {
        Test test = new Test();
        ExecutorService executorService = Executors.newCachedThreadPool();
        //注意线程执行的先后顺序，如果后执行after，那么挂起的这个线程将没有其他线程来将其唤醒
        executorService.execute(() -> test.after());
        executorService.execute(() -> test.before());
        executorService.shutdown();
    }
}
```

~~~ txt
notify thread in wait
wait to be notified
~~~



### await() signal() signalAll()

java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调。

与Object类中的 wait()、notify()、notifyAll()这三个方法类似。

~~~ java
public class Test {

    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();  //使用lock实例来获取一个Condition对象

    //before方法是唤醒其他方法的方法
    public void before() {
        lock.lock();
        try {
            System.out.println("signal the waitting thread");
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    //after方法是要被唤醒的方法
    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println("thread in await");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        Test test = new Test();
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(() -> test.after());
        executorService.execute(() -> test.before());
    }
}
~~~

~~~ text
thread in await
signal the waitting thread
~~~





## 线程运行中常用的方法

### Thread.sleep(ms)和Thread.yield()的基本使用

~~~ java
public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("当前线程正在运行中...，可以小小阻塞一会儿");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("当前线程主要部分已经运行完毕，可以通知其他等待中的线程了");
                Thread.yield();
            }
        });
    }
}
~~~

- Thread.sleep(ms)：该方法会朽迈你当前正在执行的线程，ms单位为毫秒
- yield()：该单词译为”让步“，当在线程运行过程中调用此方法说明当前线程已经完成生命周期中最重要的部分，可以通知操作系统将线程资源多分配给其他线程。