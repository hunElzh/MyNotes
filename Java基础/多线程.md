## 线程的状态转换

![WUF6TJBSTECPQC6P6IE](..\img\WUF6TJBSTECPQC6P6IE.png)

- 新建（New）：创建后尚未启动

- 可运行（Runnable）：可能正在运行，也可能在等待CPU的时间片。包含操作系统中的Running和Ready

- 阻塞（Blocked）：线程阻塞，当前线程停止运行。由`排他锁`引起，如果其线程释放了锁就会结束此状态

- 有期限等待（Time Waiting）：线程进入等待状态，当设定时间一到，线程继续执行

  ![5S0HV23V0YW6$2JZRA](..\img\5S0HV23V0YW6$2JZRA.png)

- 无期限等待（Waiting）：与有期限等待对应，只有通过特定的退出方法才可继续执行线程

  ![L64QLMMQ1MLOCWR8F](E:\Java\GitRepository\MyNotes\img\L64QLMMQ1MLOCWR8F.png)

- 终止（Terminated）：线程运行结束或者运行过程中产生了异常

## 创建线程的三种方法

- 继承Thread
- 实现Callable/Runnable接口

那现在我们来观察一下下列这仨创建线程的方法：

```java
class ExtendThread extends Thread{
    @Override
    public void run() {
        System.out.println(currentThread().getName()+" start");
    }
}

class ImpRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println("runnable start");
    }
}

class ImpCallable implements Callable{
    @Override
    public Object call() throws Exception {
        System.out.println("callable start");
        return "success";
    }
}

public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExtendThread thread1 = new ExtendThread();
        ImpRunnable runnable1 = new ImpRunnable();
        ImpCallable callable1 = new ImpCallable();

        //执行Thread线程
        thread1.start();
		
        //执行Runnable线程
        Thread thread2 = new Thread(runnable1);
        thread2.start();

        //执行Callable线程
        FutureTask futureTask1 = new FutureTask(callable1);
        Thread thread3 = new Thread(futureTask1);
        thread3.start();
        System.out.println(futureTask1.get());
    }
}
```

通过实现接口创建线程的好处

1. 实现接口之后还可以继承其他类，而继承Thread创建接口对象的话就无法继承其他类
2. 一个线程类只需要重写Thread的run方法即可，如果单独继承Thread的话开销过大



## 基础线程机制

### 线程池的创建

>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

Java中线程池的创建主要是通过Executors类来实现的。接下来通过例子简单看一下线程池的使用

~~~ java
public class Test extends Thread{

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 5; i++) {
            //线程池执行任务
            executorService.execute(new Test());
        }
        executorService.shutdown();
    }

    @Override
    public void run() {
        System.out.println(currentThread().getName()+"execute");
    }
}
~~~

首先，我们可以通过Executors的方法来创建ExecutorService(线程池)对象。Executor创建线程池的方法主要有以下几种

1. newCachedThreadPool()：一个任务创建一个线程
2. newFixedThreadPool(int nThreads)：线程池中的任务只能使用固定大小的线程nThreads
3. newSingleThreadExecutor()：相当于newFixedThreadPool(1)，即该线程池中的任务只能使用一个线程

然后调用executorService.execute(Thread对象)执行对应线程

最后调用executorService.shutdown()来关闭线程 



### 守护线程(应该不重要吧)

> 守护线程是一个程序运行时，在后台提供服务的线程。守护线程不是程序不可或缺的部分，因此只需要简单的了解

当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。我们使用setDaemon()方法将一个线程设置为守护线程。

~~~ java
public class Test extends Thread{

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Test test = new Test();
        test.setDaemon(true);
    }

    @Override
    public void run() {
        System.out.println(currentThread().getName()+"execute");
    }
}
~~~

从上面的例子中我们将继承Thread类的Test类设置了一个守护线程

Java中main方法就是一个非守护线程，当main执行完毕之后，main中的守护线程全都会被杀死



## 线程中断

### 使用interrupt()方法调用线程中断

> 当线程中有抛出InterruptedException这个异常时，调用interrupt()方法即可中断线程

```java
public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    System.out.println(Thread.currentThread().getName() + " start");
                    Thread.sleep(2000);
                    System.out.println(Thread.currentThread().getName() + " running");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        thread.start();
        thread.interrupt();
        System.out.println("Main Run");
    }
}
```

![BTUKJ0KXSB3IHUR3A](..\img\BTUKJ0KXSB3IHUR3A.png)

线程的interrupt()方法是由Thread.sleep()方法引起的，当调用了当前线程thread.interrupt()方法后就会抛出InterruptedException，从而提前结束当前线程。正如上图，若没有调用interrupt()方法，那么线程将不会中断。

需要注意的时，interrupt()方法只能中断处于**阻塞、期限等待或者无限期等待**状态的线程，如果线程处于**I/O阻塞和synchronized锁阻塞**的话，将无法被中断。

但如果，一个线程进入了死循环，并且在其中没有抛异常的话，interrupt() 方法将毫无用处，这种情况要如何才能中断当前线程呢？



### 使用interrupted()方法中断线程

如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。

但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 ture。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。

~~~ java
public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                //在无限循环中调用interrupted()方法，当在外部调用interrupt()方法后，
                while (true) {
                    //interrupted()方法像是一个标记方法，当在外部调用interrupt()方法后，Thread.interrupt()方法返回ture，循环结束
                    if (Thread.interrupted()) {
                        break;
                    }
                }
                System.out.println("thread end");
            }
        });

        thread.start();
        thread.interrupt();
    }
}
~~~

![zzzzzzzz6s7d97as9](E:\Java\GitRepository\MyNotes\img\zzzzzzzz6s7d97as9.png)

执行上面的程序，运行结果如上图所示，线程中的死循环被 Thread.interrupted() 打破



### 使用Executor中断线程

> Executor是用来创建线程池的，它的shutdownNow()方法可以中断当前所有线程。若用此方法来中断线程，那么线程池中的所有线程都将被影响。

~~~ java
public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //创建线程池
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    System.out.println("before interrupt");
                    Thread.sleep(2000);
                    System.out.println("after interrupt");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        //shutdown()方法相当于对线程池中的所有线程执行了一遍interrupt()方法
        executorService.shutdownNow();
    }
}
~~~

调用executor Service.shutdownNow()方法相当于对线程池中的每一个线程都调用 interrupt() 方法。

如果指向中断Executor中的一个线程，可以通过 submit() 方法来提交一个线程，他会返回一个 Future<?> 对象，通过调用该对象的 cancel(true) 方法并传递参数true即可 中断线程。



## 互斥同步

> Java提供了两种锁机制来控制多个**线程对共享资源的互斥访问**

- 第一个是 JVM 实现的 synchronized
- 而另一个是 JDK 实现的 ReentranLock



### synchronized

在synchronized关键字修饰的代码作用域中，线程同步

#### 同步一个代码块

~~~ java
synchronized(对象) {
    //...
}
~~~

如果要同步代码块，那么不同的线程传入的这个对象必须是同一个对象。如果同步代码块前传入的对象不是同一个对象的话，就不会进行同步。正因为这个机制，我们可以设置一个全局的对象，以保证静态代码块的同步

（为什么传入不同的对象就不会同步呢？）

- 使用synchronize同步代码块实现线程同步

  ```java
  class SynchronizedExample {
      public void fun1() {
          //同步一个代码块时，需要传入同一个对象，无法成功同步
          synchronized (Test.class) {
              for (int i = 0; i < 10; i++) {
                  System.out.print(i+" ");
              }
          }
      }
  }
  
  public class Test {
      public static void main(String[] args){
          SynchronizedExample syn1 = new SynchronizedExample();
          //Executors.newCachedThreadPool()，每传入一个runnable实例就会创建一个线程
          ExecutorService executorService = Executors.newCachedThreadPool();
          //这里向Runnable中传入实力类的方法，估摸着jdk把这个方法通过特定方式写入到run()方法中去了
          executorService.execute(() -> syn1.fun1());
          executorService.execute(() -> syn1.fun1());
          executorService.shutdown();
      }
  }
  ```

  ![zzzzz979r379327894](E:\Java\GitRepository\MyNotes\img\zzzzz979r379327894.png)

- 当传入不同对象时线程执行异步

  ```java
  class SynchronizedExample {
      public void fun1() {
          //同步一个代码块时，需要传入同一个对象，无法成功同步
          synchronized (Test.class) {
              for (int i = 0; i < 10; i++) {
                  System.out.print(i+" ");
              }
          }
      }
  }
  
  public class Test {
      public static void main(String[] args){
          SynchronizedExample syn1 = new SynchronizedExample();
          SynchronizedExample syn2 = new SynchronizedExample();
          //Executors.newCachedThreadPool()，每传入一个runnable实例就会创建一个线程
          ExecutorService executorService = Executors.newCachedThreadPool();
          //这里向Runnable中传入实力类的方法，估摸着jdk把这个方法通过特定方式写入到run()方法中去了
          executorService.execute(() -> syn1.fun1());
          executorService.execute(() -> syn2.fun1());
          executorService.shutdown();
      }
  }
  ```

  ![zzzzs9d7f923894v7](E:\Java\GitRepository\MyNotes\img\zzzzs9d7f923894v7.png)
  
  
  
- 只要是相同对象，就都能同步

  ~~~ java
  public class Test {
  
      //定义一个全局的对象，保证代码块中线程同步
      static Object object = new Object();
  
      static class SynchronizedExample {
          public void fun1() {
              synchronized(object) {
                  for (int i = 0; i < 10; i++) {
                      System.out.print(i+" ");
                  }
              }
          }
      }
  
      public static void main(String[] args){
          SynchronizedExample syn1 = new SynchronizedExample();
          SynchronizedExample syn2 = new SynchronizedExample();
          ExecutorService executorService = Executors.newCachedThreadPool();
          executorService.execute(() -> syn1.fun1());
          executorService.execute(() -> syn2.fun1());
          executorService.shutdown();
      }
  }
  ~~~

  

#### 同步一个方法

~~~ java
public synchronized void fun() {
    //...
}
~~~

它和同步代码块一样，作用于同一个对象



#### 同步一个类

~~~ java
public void fun() {
    synchronized (Test.class) {
        //...
    }
}
~~~

传入一个类作为参数，不论该类实例化多少个对象，它们同步区块中的内容一定同步。

~~~ java
class SynchronizedExample {
    public void fun1() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i < 10; i++) {
                System.out.print(i+" ");
            }
        }
    }
}

public class Test {
    public static void main(String[] args){
        SynchronizedExample syn1 = new SynchronizedExample();
        SynchronizedExample syn2 = new SynchronizedExample();
        ExecutorService executorService = Executors.newCachedThreadPool();
        //由于同步是针对SynchronizedExample这个类的，所以
        executorService.execute(() -> syn1.fun1());
        executorService.execute(() -> syn2.fun1());
        executorService.shutdown();
    }
}
~~~

![zzzzzzzasd97wef616a78gagsd](..\img\zzzzzzzasd97wef616a78gagsd.png)

#### 同步一个静态方法

~~~ JAVA
public synchronized static void fun() {
    //...
}
~~~

作用于整个类



### ReentrantLock





## 线程运行中常用的方法

### Thread.sleep(ms)和Thread.yield()的基本使用

~~~ java
public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("当前线程正在运行中...，可以小小阻塞一会儿");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("当前线程主要部分已经运行完毕，可以通知其他等待中的线程了");
                Thread.yield();
            }
        });
    }
}
~~~

- Thread.sleep(ms)：该方法会朽迈你当前正在执行的线程，ms单位为毫秒
- yield()：该单词译为”让步“，当在线程运行过程中调用此方法说明当前线程已经完成生命周期中最重要的部分，可以通知操作系统将线程资源多分配给其他线程。