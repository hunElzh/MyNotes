## HashMap

### 底层数据结构

jdk1.7之前，HashMap底层数据结构为数组+链表；jdk1.8，HashMap底层数据结构为数组+链表（红黑树）



### HashMap的扩容机制

HashMap 数组初始容量为0，当第一次调用put()方法时，HashMap扩容为16，之后每次扩容，数组容量为之前的两倍

令 HashMap 扩容的条件有两个，不需要同时满足

1. map.put()操作后，链表长度大于8（若此时扩容后他们计算得到的桶下标还是相等，此时的链表长度就大于8，这是有可能的只不过可能性很小）
2. map.put()操作后，链表元素节点数大于 **数组容量 * 负载因子**（默认为0.75）

负载因子：决定扩容结点数的一个值，默认为 0.75



### HashMap的树化机制

令 HashMap 树化的条件有两个，并且必须同时满足

1. 链表长度大于8
2. 数组长度大于64

正因如此，当数组长度为16，链表长度为8，此时此时加入一个key，该key哈希后的索引为链表长度为8的那个数组元素上时，此时数组扩容，链表长度+1等于9。因此jdk1.8之后的HashMap中链表长度是可以大于8的。



### 为什么HashMap不一开始就树化？为什么HashMap树化阈值为8？

1. 正常情况下，hash值足够随机，则 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过8的链表出现的概率是 0.00000006，选择8就是为了让树化几率足够小，并且此时链表的查询速度并不比红黑树慢多少。**为什么HashMap树化阈值为8**
2. 由1可知，正常情况下是不会出现树化的情况的，jdk设计者们设计红黑树主要是为了防止DoS攻击，可以传入大量hash值相同的数据最终导致系统变慢
3. **HashMap 在链表长度短的时候，查询效率其实不比红黑树差**，想一下就tm8个元素，又因为泊松分布，几千万条数据中可能就零星几颗树，因此在链表长度短的情况下完全没必要树化，并且树化之后的 TreeNode 占用空间还大于 Node，得不偿失



### HashMap树如何退化为链表？（强行记忆）

1. 在扩容时，如果树被拆分，并且树元素个数 <= 6 则树会退化为链表
2. remove 树节点时，若 root、root.left、root.right、root.left.left 中有一个为 null，红黑树也会退化为链表



### HashMap索引如何计算？为什么要进行二次哈希？数组容量为什么是2的n次幂？

**HashMap索引计算为如下三步**

1. 计算对象的 hashCode()
2. 用1的结果调用 HashMap.hash() 方法得到二次 hash 值**（二次哈希的目的是为了让key分布的更加均匀）**
   - jdk1.8中 HashMap.hash(1^1>>>16)  此处的1是步骤1的结果
3. 用2的结果 % 数组长度 = index
   - 当数组长度为2的n次幂时，可以通过位运算得到index（index = 2的结果 & （数组长度-1））   **1. 方便位运算获取key的索引**
   - 扩容时，hash & oldLen == 0 的元素留在原来的数组索引处；否则 newIndex = oldIndex + oldLen   **2. 方便获取扩容后的key索引**

HashMap计算索引的 1、2、3 这三个步骤都是为了配合容量为 2 的 n 次幂时的所创建出来的 优化手段。例如 HashTable 的容量就不是 2 的 n 次幂



### HashMap1.8 put()方法流程，1.7与1.8有何不同？

- HashMap1.8 put() 流程
   1. HashMap 时懒惰创建数组的，即首次调用put()方法才创建数组
   2. 计算key索引**（桶下标）**
   3. 如果当前桶下标还没被占用，创建 Node 占位并返回
   4. 如果当前桶下标已经有人占用
      1. 已经是 TreeNode 走红黑树添加或更新逻辑
      2. 如果还是 Node 长度没有超过阈值，走更新逻辑；长度超过阈值，走树化逻辑
   5. 返回当前 key 数量是否超过阈值，一旦超过就对数组进行扩容（**HashMap是先插入元素，随后再进行扩容，扩容后元素的索引还会发生改变哦**）

   

- 1.7与1.8 put()的不同之处如下
  1. 链表插入数组对应时不同，1.7是头插法，1.8是尾插法	
  2. 1.8 在扩容后计算 Node 索引时，会优化



### 负载因子为何默认是 0.75f？（究其原理可能会十分复杂，所以死记硬背）

1. 在空间占用与查询事件之间取得较好的权衡
2. 大于这个值，空间节省了，但链表会比较长，影响性能
3. 小于这个值，冲突减少了，但扩容就会更频繁，空间占用多



### 多线程下操作 HashMap 会有啥问题？（有被问道过的）

1. 扩容死链（1.7）
2. 数据错乱（1.7、1.8）



### HashMap 中key能否为 null，作为 key 的对象有什么要求

1. HashMap 中的 key 可以为 null，但 Map 的其他实现则不然（HashTable、TreeMap的key不能为null）
2. 作为 HashMap 中的 key 的对象，该对象必须实现 hashCode 和 equals。
3. key 的内容不能修改，若 key 的值修改之后，桶下标将会发生改变。



### hashCode()方法是如何实际的，为什么每次都是乘 31

- hashCode() 方法的最终目的是使计算出来的结果能够均匀分布 



















