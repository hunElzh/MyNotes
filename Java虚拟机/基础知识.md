## JVM内存结构

#### JVM 基本的内存结构

![zzzzmer98m4e9xq971354n7](..\img\zzzzmer98m4e9xq971354n7.png)

- 程序计数器：**保存当前程序执行字节码位置**，每个线程都有其独立的程序计数器。执行 native 方法时，程序计数器为空。
- Java虚拟机栈（栈）：又称方法栈，线程私有。线程执行方法时都会创建一个栈帧，用来存储**方法局部变量，方法参数，动态链接，方法出口**等信息。
- 本地方法栈：与栈类似，也是用来保存执行方法的信息，只不过本地方法栈保存 native 方法。
- 堆：**存放对象实例**。几乎存储所有的对象实例，当队中没有可用空间时，会抛出 OOM 异常。根据对象存货周期不同，JVM 把对象进行分代管理，由垃圾回收器进行垃圾的回收管理。
- 方法区：又称非堆区，在内存中存储读取到的**类的字节码文件信息**，这些信息包含包含：类名、类继承关系、类的成员变量、类引用的其他类的类名、类中的方法代码
- 解释器：将Java字节码翻译成为各个平台能够执行的机器码。若执行10w次a++，解释器就要加载10w次，因此效率会受到影响，此时 JIT 就被引入。
- 即时编译器（JIT）：将经常执行的热点代码进行缓存成机器码。不需要每次执行都调用解释器去将字节码进行编译。
- 垃圾回收：



#### 面试题：Java 内存结构中会出现内存溢出的地方

- OutOfMemory：
  - 堆内存耗尽(主要) - 创建的对象越来越多，并且他们一直都在被引用，最终会导致虚拟机的堆内存不够用
  - 方法区内存耗尽 - 虚拟机加载的类过多导致耗尽方法区内存
  - 虚拟机栈内存耗尽 - 每个线程最多会占用 1 M 内存，线程个数过多导致虚拟机栈内存被耗尽
- StackOverflowError：
  - 虚拟机栈内部 - 方法调用次数过多导致虚拟机栈溢出（方法的错误递归调用）



#### 面试题：方法区与永久代和元空间的联系

- 方法区是 JVM 规范中定义的一块儿内存区域，用来存储类字节码文件信息等
- 永久代是 Hotspot 虚拟机对 JVM 规范的实现（1.8之前）
- 元空间是 Hotspot 虚拟机对 JVM 规范的实现（1.8以后）



## JVM 内存参数

#### JVM 内存分区

- 堆内存分区
  - 新生代：
    - 伊甸园：对象最初都会被分配到此处
    - 幸存区：当伊甸园内存不足时，进行一次垃圾回收，回收后幸存的对象会被分配至此，此处采用标记复制算法
      - form
      - to
  - 老年代：当幸存区对象熬过多次垃圾回收（最多15次），该对象会晋升到老年代（幸存区内存不足或对象过大会导致对象提前晋升）
- 方法区内存分区（有点模糊）
  - class space：存储类的基本信息，包括类名、方法入口
  - non-class space：存储类的字节码、注解等信息

#### JVM 内存参数概览

- 堆内存参数
  - -Xmx：JVM 最大堆内存大小
  - -Xms：JVM 基本堆内存大小
  - -Xmn：JVM 新生代堆内存大小（-XX:MaxNewSize 和 -XX:MaxNew 大小相同时可用 -Xmn表示）
    - -XX:MaxNewSize：新生代最大值
    - -XX:NewSize：新生代默认大小
  - -XX:SurvivorRatio：eden : from（默认值 8:1）
  - -XX:NewRatio：old : new
- 方法区(元空间)内存参数：
  - -XX:CompressedClassSpaceSize：设置 class space 最大内存
  - -XX:MaxMetaspaceSize：设置方法区总内存大小（默认为物理内存）
- 虚拟机栈内存参数：
  - -Xss：控制每个线程虚拟机栈占用内存大小

#### 面试题：对于 JVM 内存配置参数：-Xmx10240m -Xms10240m -Xmn5120m -XX:SurvivorRatio=3 其最小内存之和 Survivor 区总大小分别是多少？

-XX:SurvivorRatio = survivor / from，又 from = to，因此 Survivor = from + to = -Xms * 2 / 5 = 2048m



## JVM 垃圾回收（garbage collector）

#### 面试题：JVM 垃圾回收算法

> 垃圾回收是针对 JVM 内存结构中的 堆内存 进行垃圾回收的？

1. 标记清除（CMS）：标记为 GC Root 指向的内存，而清除的对象是未被标记的区域。**（基本不使用了）**
   - 优点：快捷高效
   - 缺点：GC 之后会造成内存碎片化，使得内存区域出现不连续的情况
2. 标记整理（）：相对标记清除多了一步整理 GC Root 标记区域**（多用于老年代）**
   - 优点：解决内存碎片化问题
   - 缺点：整理步骤需要拷贝内存（我猜的），导致效率降低
3. 标记复制（）：专门开辟一块 内存区域from 用于存储标记被标记的对象，在对象于 内存区域to 被标记后，该对象会被复制至 内存区域to，并按顺序存储，当 GC 时直接清除 内存区域from**（多用于新生代）**
   - 优点：内存回收速度十分快，并且 GC 后不会出现碎片化问题
   - 缺点：更加耗费内存空间，上述 内存区域to 就是相对于其他两种回收算法的额外的内存区域

**老年代和新生代的区别**

- 新生代 GC 频繁，老年代 GC 相对较少
- 新生代存活对象较少，内存占用不多；老年存活对象较多，占用内存较多



#### 面试题：说说 GC 和 分代回收算法

- GC 是什么：GC 英文全称为 garbage collector，译为 垃圾回收器。垃圾回收器的具体实现有很多，例如CMS、G1等
- GC 的目的：**实现无用对象内存的自动释放**，减少内存碎片并使内存创建速度提高
- GC 主要功能：
  1. GC 仅针对 JVM 内存结构中的**堆内存**进行垃圾回收。虚拟机栈在方法调用完毕后会自动释放堆内存。
  2. 判断无用对象，使用 `可达性分析算法，三色标记法` 标记存活对象，未标记对象则直接回收。
  3. GC 大都采用了 `分代回收思想`。根据对象的特性将回收区分为 **新生代** 和 **老年代**，新生代中的对象由于暂时被引用的缘故，因此大部分都会被回收，而老年代中的对象都是一些长期被引用的对象。
  4. 根据 GC 的规模可以分称 Minor GC，Mixed GC（**G1特有**），Full GC
     - Minor GC：针对新生代的 GC
     - Mixed GC：新生代和部分老年代
     - Full GC：新生代和老年代全量 GC



#### 三色标记法与并发漏标问题

- 三色标记法：用三种颜色记录对象的标记状态

  1. 黑色 - 已标记	
  2. 灰色 - 标记中
  3. 白色 - 尚未标记

- 并发漏标问题：GC 的标记线程在标记过程中，用户线程对用户对象进行了更改，会导致对象漏标最终导致误删对象的情况产生

  1. Incremental Update
     1. 只要赋值发生，被赋值的对象就会被记录（A a = new A()，其中对象实例  会被记录）

  2. Snapshot At The Beginning，SATB
     1. 在垃圾回收线程执行过程中，新加对象会被记录
     2. 在垃圾回收线程执行过程中，被删除引用关系的对象也被记录



#### Jvm垃圾回收器





## 类的加载过程、双亲委派（有些还未理解）

#### 类加载过程的三个阶段

- 加载（Student.class、Class.forName(com.lzh.Student)）
  - 将字节码文件载入方法区，并创建 Class 类对象
  - 如果此类的父类/接口还没有加载，那么还需先加载父类/接口
  - 此时 `static final` 修饰的**基本数据类型变量**会被赋值并存储在常量池中
- 链接
  - 验证：验证类是否符合 Class 规范，对类进行合法性、安全性检测
  - 准备：为 `static` 修饰的变量**分配内存空间**，设置默认值
  - 解析：将常量池的 符号引用 解析为 直接引用（还不太理解）
- 初始化（new Student()）：**注意类的初始化不是对象实例的初始化**
  
  - 执行`静态代码块`与`非final静态变量`的**赋值**
- 类的加载和初始化都是懒惰执行的，即执行类加载、类初始化时才会被分配内存空间

  

#### 双亲委派机制

- 所谓的双亲委派，就是指**优先委派上级类加载器进行加载**
  - 上级类加载器能找到这个类，由上级加载
  - 上级类加载器无法找到这个类，此时下级类加载器才有资格加载此类，若还是不能加载，继续委派至下级

![zzzzzzz320bajernbasd](..\img\zzzzzzz320bajernbasd.png)

#### static 与 final 

- static 修饰的 类、变量、代码块等，均在类的链接过程被分配内存空间，在类的初始化过程被赋值
- static final 修饰的**基本数据类型变量**在**类加载时**被分配内存空间并赋值
- static final 修饰的**引用数据类型变量**在**类初始化时**被赋值



## 强软弱虚

![zzzzzzzzzzzzzz23094ujaspbu](..\img\zzzzzzzzzzzzzz23094ujaspbu.png)



## 一些小点

#### 常量池的区别

- 堆的常量池：在堆中，String就存于此
- 运行时常量池：在方法区中