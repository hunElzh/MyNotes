### 题目描述

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。



> 示例 1：
>
> 输入：[3, 2, 1]
> 输出：1
> 解释：第三大的数是 1 。
> 示例 2：
>
> 输入：[1, 2]
> 输出：2
> 解释：第三大的数不存在, 所以返回最大的数 2 。
> 示例 3：
>
> 输入：[2, 2, 3, 1]
> 输出：1
> 解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
> 此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。



### 官方题解

```java
public static int removeDuplicates(int[] nums) {
    // 特判
    if (nums.length == 0 || nums == null) {
        return 0;
    }
    //num[0,left] 存的是所有不重复的数组，right负责遍历数组
    int left = 0;
    for (int right = 1; right < nums.length; right++) {
        if (nums[left] != nums[right]) {
            nums[++left] = nums[right];
        }
    }
    return left + 1;
}
```



### 算法思路

- 原地算法：数组传参给函数，数组在函数中是以引用的形式存在的，在函数中改变数组的内容会影响到函数外数组的值
- 双指针算法：使用双指针分别指向数组中的元素，当出现特定情况，就针对双指针指向的数组元素执行特定的操作