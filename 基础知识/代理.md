### 啥是动态代理？

> 在 Java 语言中，非抽象类是可以直接通过 new 进行实例化；而接口并不能实例化，他只能被一个类所实现，再通过向上转型的防止而实例化。







### 代理设计模式概括

> 代理是一种设计模式，提供了对目标对象的简介访问方式，即类通过代理访问目标对象。如此便于在目标对象方法实现的基础上增加额外的功能操作——前拦截，后拦截等，以满足自身业务需求。

![v2-6e2fa8c8c02e0f04a601cdd951045f82_720w](E:\Java\GitRepository\MyNotes\img\v2-6e2fa8c8c02e0f04a601cdd951045f82_720w.png)

常用的代理方式可以粗略划分为：静态代理和动态代理。

静态代理的基本实现：编写一个代理类，实现与目标对象相同的接口，并在内部维护一个目标对象的引用。通过构造方法将目标对象注入进代理对象中，此时目标对象就成为代理类中的一个字段（属性），此时可以通过代理对象中调用目标对象的同名方法，并添加前拦截、后拦截等所需业务功能。



### 不使用代理，直接修改源程序的例子

> 在没有应用代理的设计模式之前，我们访问对象的方法如下图所示

![0C~BG9$EEHTSVT2X7KR6KJ](E:\Java\GitRepository\MyNotes\img\0C~BG9$EEHTSVT2X7KR6KJ.png)

现在有一个计算器类，想在其运算开始和结束时打印日志

~~~ java
public class Calculator {

    public int add(int a, int b) {
        int result = a + b;
        return result;
    }

    public int substract(int a, int b) {
        int result = a - b;
        return result;
    }

}
~~~

最简单的方法就是修改Calculator类

~~~ java
public class Calculator {

    public int add(int a, int b) {
        System.out.println("add start...");
        int result = a + b;
        System.out.println("add end...");
        return result;
    }

    public int sub(int a, int b) {
        System.out.println("sub start...");
        int result = a - b;
        System.out.println("sub end...");
        return result;
    }

}
~~~

直接修改Calculator类存在的问题

1. 直接修改源程序，不符合开闭原则。应对扩展开发，对修改关闭
2. 如果类似 Calculator 的类有几十、上百个的话，这样修改量太大
3. 存在很多重复代码（日志打印代码写在所有核心代码前后，若核心代码很多，就会显得十分冗杂）
4. 日志打印硬编码在源程序中，不利于后期维护：若加入Caculator类日志需求更改成为打印算式详细过程，那这样需要到源程序中一行行更改，不仅麻烦，还有可能一次性无法完全更改的情况出现！

因此直接修改源程序不可取！



### 使用静态代理实现上面的 Caculator 类

- 将之前的 Caculator 类改为接口
- 创建目标类 CaculatorImpl 实现 Calculator
- 创建代理类 CaculatorPorxy 实现 Calculator

~~~ JAVA
//创建一个Calculator接口
public interface Calculator {
    public int add(int a, int b);
    public int sub(int a, int b);
}
~~~

~~~ JAVA
//创建一个Calculator类实现接口中的方法
public class CalculatorImpl implements Calculator {

    @Override
    public int add(int a, int b) {
        int result = a + b;
        return result;
    }

    @Override
    public int sub(int a, int b) {
        int result = a - b;
        return result;
    }
}
~~~

~~~ JAVA
//创建一个Caculator代理对象，在其中引入目标对象，并重写方法，此后调用代理对象，并将目标对象作为参数传递给代理对象，就能实现对目标对象的静态代理
public class CalculatorProxy implements Calculator{

    //将带泪对象内部维护一个目标对象的引用
    private Calculator target;

    public CalculatorProxy(Calculator target) {
        this.target = target;
    }

    //相当于在代理方法中再次调用了目标对象的方法，但是代理对象在没有修改目标对象的前提下对其进行了扩展
    @Override
    public int add(int a, int b) {
        System.out.println("add方法开始...");
        int result = target.add(a, b);
        System.out.println("add方法结束...");
        return result;
    }

    @Override
    public int sub(int a, int b) {
        System.out.println("subtract方法开始...");
        int result = target.sub(a, b);
        System.out.println("subtract方法结束...");
        return result;
    }
}
~~~

静态代理保证了设计原则中的开闭原则，即对目标对象扩展开放，修改关闭，但是也仅解决了这一个缺点，还剩下三个缺点

1. 如果Caculator有几十个、上百个方法，修改量太大
2. 存在重复代码（使用静态代理，日志打印代码重复写在多个代理类中类中）

3. 日志打印硬编码在代理类中，不利于后期维护：若加入Caculator类日志需求更改成为打印算式详细过程，那这样需要到源程序中一行行更改，不仅麻烦，还有可能一次性无法完全更改的情况出现！

#### 静态代理的问题

上面这个案例中，代理类是我们事先编写的，而且要和目标对象实现相同接口。由于 CalculatorImpl（目标对象）需要日志功能，于是乎就编写了 CalculatorProxy（代理对象），并通过代理对象的构造器传入目标对象，调用目标对象同名方法的同时，添加增强代码。

此案例中有一个验证共你的问题，代理对象构造器接收的参数类型是 Calculator，这意味着它只能接收Calculator的实现类对象，亦即我们写的代理类 CalculatorProxy 只能给 Calculator 做代理，这个代理对象与 Calculator 绑定死了。假设此时我们的系统需要全面改造，给其他类也添加日志打印功能，就得为其他几百个接口都写一份代理类，海量的工作量显然不是我们想要达到的最终目的。

每对目标对象进行扩展，我们就需要手动编写一个代理类，通过代理类实例化出来的代理对象，我们即可实现对当前目标对象的扩展，由此可见，**我们想要的其实并不是这个存储在硬盘上的代理类，而是代理类在运行过程中实例化出来存储在内存中的代理对象**。那么能否让 JVM 根据接口自动生成代理对象呢？又或者说，又没有这样一种方法，当我们传入一个接口时，它可以给我们返回一个接口的代理对象。

![v2-04157e707582d34233d6ae0eb5bf6867_720w](E:\Java\GitRepository\MyNotes\img\v2-04157e707582d34233d6ae0eb5bf6867_720w.png)





### 动态代理

> 首先阐明一个结论：静态代理通过**代理类**实现了**增强代码**与**目标对象**的解耦，但此时**代理类**却与**增强代码**耦合了，而动态代理就实现了**代理类**与**增强代码**的解耦

#### 动态代理的目的是要实现

1. 自动生成代理对象，免去编写代理类的痛苦
2. 增强方法与代理类解耦，达到增强方法的复用

根据结果推原因，我们最终想要实现的是，拿到 **目标对象** 和 **增强方法**，而代理对象则可以自动生成。

#### 简单温习对象的生成过程

1. ClassLoader 将 .class 文件加载至内存
2. 执行静态代码块和静态初始化语句
3. 调用构造器，创建一个空的对象
4. 子类调用父类构造器
5. 执行构造器（执行构造代码块和初始化语句）

由上述对象实例化过程我们可以得知，想要实例化一个对象，只需要得到该对象的 Class类 就足够了，对象的 Class类 有如下三种创建方式。`Class类是泛型类，它可以根据传入的泛型改变对应类型`

1. Class clazz = class.forName("com.lzh.Person");
2. Class clazz = Person.class;
3. Class clazz = Person.getClass();

这三种创建Class对象的方法，无不需要对应的类，此时我们不得不从其他方面入手（接口和父类），以获取到对应的代理对象。



#### 通过接口，生成动态代理对象！

先看下面这个例子

~~~ java
public Interface Calculator{
    int add(int a, int b);
}

//目标对象
public Class CalculatorImpl implements Calculator{
    public int add(int a, int b) {
        return a + b;
    }
}

//代理对象
public Class CalculatorProxy{
    CalculatorImpl target;
    
    public Proxy(Calculator target) {
        this.target = target;
    }
    
    public int add(int a, int b) {
        ----------log before---------
        target.add(a, b);
        ----------log after----------
    }
}
~~~

细品这个例子，代理类或者说代理对象它重要吗？他其实只是一个空壳，它仅仅只是调用了目标对象的方法，并在目标对象方法周围添加了一段增强代码而已，代理对象？呵，空壳而已。

**因此可以得出动态代理的最终目的：为目标对象增加增强代码。**














