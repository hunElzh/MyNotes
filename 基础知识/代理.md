### 啥是动态代理？

> 在 Java 语言中，非抽象类是可以直接通过 new 进行实例化；而接口并不能实例化，他只能被一个类所实现，再通过向上转型的防止而实例化。







### 代理设计模式概括

> 代理是一种设计模式，提供了对目标对象的简介访问方式，即类通过代理访问目标对象。如此便于在目标对象方法实现的基础上增加额外的功能操作——前拦截，后拦截等，以满足自身业务需求。

![v2-6e2fa8c8c02e0f04a601cdd951045f82_720w](E:\Java\GitRepository\MyNotes\img\v2-6e2fa8c8c02e0f04a601cdd951045f82_720w.png)

常用的代理方式可以粗略划分为：静态代理和动态代理。

静态代理的基本实现：编写一个代理类，实现与目标对象相同的接口，并在内部维护一个目标对象的引用。通过构造方法将目标对象注入进代理对象中，此时目标对象就成为代理类中的一个字段（属性），此时可以通过代理对象中调用目标对象的同名方法，并添加前拦截、后拦截等所需业务功能。



### 不使用代理，直接修改源程序的例子

> 在没有应用代理的设计模式之前，我们访问对象的方法如下图所示

![0C~BG9$EEHTSVT2X7KR6KJ](E:\Java\GitRepository\MyNotes\img\0C~BG9$EEHTSVT2X7KR6KJ.png)

现在有一个计算器类，想在其运算开始和结束时打印日志

~~~ java
public class Calculator {

    public int add(int a, int b) {
        int result = a + b;
        return result;
    }

    public int substract(int a, int b) {
        int result = a - b;
        return result;
    }

}
~~~

最简单的方法就是修改Calculator类

~~~ java
public class Calculator {

    public int add(int a, int b) {
        System.out.println("add start...");
        int result = a + b;
        System.out.println("add end...");
        return result;
    }

    public int sub(int a, int b) {
        System.out.println("sub start...");
        int result = a - b;
        System.out.println("sub end...");
        return result;
    }

}
~~~

直接修改Calculator类存在的问题

1. 直接修改源程序，不符合开闭原则。应对扩展开发，对修改关闭
2. 如果类似 Calculator 的类有几十、上百个的话，这样修改量太大
3. 存在很多重复代码（日志打印代码写在所有核心代码前后，若核心代码很多，就会显得十分冗杂）
4. 日志打印硬编码在源程序中，不利于后期维护：若加入Caculator类日志需求更改成为打印算式详细过程，那这样需要到源程序中一行行更改，不仅麻烦，还有可能一次性无法完全更改的情况出现！

因此直接修改源程序不可取！



### 使用静态代理实现上面的 Caculator 类

- 将之前的 Caculator 类改为接口
- 创建目标类 CaculatorImpl 实现 Calculator
- 创建代理类 CaculatorPorxy 实现 Calculator

~~~ JAVA
//创建一个Calculator接口
public interface Calculator {
    public int add(int a, int b);
    public int sub(int a, int b);
}
~~~

~~~ JAVA
//创建一个Calculator类实现接口中的方法
public class CalculatorImpl implements Calculator {

    @Override
    public int add(int a, int b) {
        int result = a + b;
        return result;
    }

    @Override
    public int sub(int a, int b) {
        int result = a - b;
        return result;
    }
}
~~~

~~~ JAVA
//创建一个Caculator代理对象，在其中引入目标对象，并重写方法，此后调用代理对象，并将目标对象作为参数传递给代理对象，就能实现对目标对象的静态代理
public class CalculatorProxy implements Calculator{

    //将带泪对象内部维护一个目标对象的引用
    private Calculator target;

    public CalculatorProxy(Calculator target) {
        this.target = target;
    }

    //相当于在代理方法中再次调用了目标对象的方法，但是代理对象在没有修改目标对象的前提下对其进行了扩展
    @Override
    public int add(int a, int b) {
        System.out.println("add方法开始...");
        int result = target.add(a, b);
        System.out.println("add方法结束...");
        return result;
    }

    @Override
    public int sub(int a, int b) {
        System.out.println("subtract方法开始...");
        int result = target.sub(a, b);
        System.out.println("subtract方法结束...");
        return result;
    }
}
~~~

静态代理保证了设计原则中的开闭原则，即对目标对象扩展开放，修改关闭，但是也仅解决了这一个缺点，还剩下三个缺点

1. 如果Caculator有几十个、上百个方法，修改量太大
2. 存在重复代码（使用静态代理，日志打印代码重复写在多个代理类中类中）

3. 日志打印硬编码在代理类中，不利于后期维护：若加入Caculator类日志需求更改成为打印算式详细过程，那这样需要到源程序中一行行更改，不仅麻烦，还有可能一次性无法完全更改的情况出现！

#### 静态代理的问题

上面这个案例中，代理类是我们事先编写的，而且要和目标对象实现相同接口。由于 CalculatorImpl（目标对象）需要日志功能，于是乎就编写了 CalculatorProxy（代理对象），并通过代理对象的构造器传入目标对象，调用目标对象同名方法的同时，添加增强代码。

此案例中有一个验证共你的问题，代理对象构造器接收的参数类型是 Calculator，这意味着它只能接收Calculator的实现类对象，亦即我们写的代理类 CalculatorProxy 只能给 Calculator 做代理，这个代理对象与 Calculator 绑定死了。假设此时我们的系统需要全面改造，给其他类也添加日志打印功能，就得为其他几百个接口都写一份代理类，海量的工作量显然不是我们想要达到的最终目的。

每对目标对象进行扩展，我们就需要手动编写一个代理类，通过代理类实例化出来的代理对象，我们即可实现对当前目标对象的扩展，由此可见，**我们想要的其实并不是这个存储在硬盘上的代理类，而是代理类在运行过程中实例化出来存储在内存中的代理对象**。那么能否让 JVM 根据接口自动生成代理对象呢？又或者说，又没有这样一种方法，当我们传入一个接口时，它可以给我们返回一个接口的代理对象。

![v2-04157e707582d34233d6ae0eb5bf6867_720w](E:\Java\GitRepository\MyNotes\img\v2-04157e707582d34233d6ae0eb5bf6867_720w.png)





















### 一个动态代理的简单例子

~~~ java
public interface DynamicProxy {
    public void helloWorld(String name);
}

class Test2 {
    public static void main(String[] args) {

        //InvocationHandler是一个函数式接口，
        InvocationHandler handler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(method);
                System.out.println(Arrays.toString(args));
                if (method.getName().equals("helloWorld")) {
                    System.out.println(args[0] + " says hello world");
                }
                return null;
            }
        };


        DynamicProxy proxy = (DynamicProxy) Proxy.newProxyInstance(
                DynamicProxy.class.getClassLoader(),
                new Class[] {DynamicProxy.class},
                handler
        );
        proxy.helloWorld("lzh");
    }
}
~~~

