### 啥是动态代理？

> 在 Java 语言中，非抽象类是可以直接通过 new 进行实例化；而接口并不能实例化，他只能被一个类所实现，再通过向上转型的防止而实例化。







### 代理设计模式概括

> 代理是一种设计模式，提供了对目标对象的简介访问方式，即类通过代理访问目标对象。如此便于在目标对象方法实现的基础上增加额外的功能操作——前拦截，后拦截等，以满足自身业务需求。

![v2-6e2fa8c8c02e0f04a601cdd951045f82_720w](E:\Java\GitRepository\MyNotes\img\v2-6e2fa8c8c02e0f04a601cdd951045f82_720w.png)

常用的代理方式可以粗略划分为：静态代理和动态代理。

静态代理的基本实现：编写一个代理类，实现与目标对象相同的接口，并在内部维护一个目标对象的引用。通过构造方法将目标对象注入进代理对象中，此时目标对象就成为代理类中的一个字段（属性），此时可以通过代理对象中调用目标对象的同名方法，并添加前拦截、后拦截等所需业务功能。



### 不使用代理，直接修改源程序的例子

> 在没有应用代理的设计模式之前，我们访问对象的方法如下图所示

![0C~BG9$EEHTSVT2X7KR6KJ](E:\Java\GitRepository\MyNotes\img\0C~BG9$EEHTSVT2X7KR6KJ.png)

现在有一个计算器类，想在其运算开始和结束时打印日志

~~~ java
public class Calculator {

    public int add(int a, int b) {
        int result = a + b;
        return result;
    }

    public int substract(int a, int b) {
        int result = a - b;
        return result;
    }

}
~~~

最简单的方法就是修改Calculator类

~~~ java
public class Calculator {

    public int add(int a, int b) {
        System.out.println("add start...");
        int result = a + b;
        System.out.println("add end...");
        return result;
    }

    public int sub(int a, int b) {
        System.out.println("sub start...");
        int result = a - b;
        System.out.println("sub end...");
        return result;
    }

}
~~~

直接修改Calculator类存在的问题

1. 直接修改源程序，不符合开闭原则。应对扩展开发，对修改关闭
2. 如果类似 Calculator 的类有几十、上百个的话，这样修改量太大
3. 存在很多重复代码（日志打印代码写在所有核心代码前后，若核心代码很多，就会显得十分冗杂）
4. 日志打印硬编码在源程序中，不利于后期维护：加入Caculator类日志需求更改成为打印算式详细过程，那这样需要到源程序中一行行更改，不仅麻烦，还有可能一次性无法完全更改的情况出现！

因此直接修改源程序不可取！



### 使用静态代理实现上面的 Caculator 类

- 将之前的 Caculator 类改为接口
- 创建目标类 CaculatorImpl 实现 Calculator
- 创建代理类 CaculatorPorxy 实现 Calculator





































































### 一个动态代理的简单例子

~~~ java
public interface DynamicProxy {
    public void helloWorld(String name);
}

class Test2 {
    public static void main(String[] args) {

        //InvocationHandler是一个函数式接口，
        InvocationHandler handler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(method);
                System.out.println(Arrays.toString(args));
                if (method.getName().equals("helloWorld")) {
                    System.out.println(args[0] + " says hello world");
                }
                return null;
            }
        };


        DynamicProxy proxy = (DynamicProxy) Proxy.newProxyInstance(
                DynamicProxy.class.getClassLoader(),
                new Class[] {DynamicProxy.class},
                handler
        );
        proxy.helloWorld("lzh");
    }
}
~~~

