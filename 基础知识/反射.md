### java创建一个对象的过程

~~~ markdown
A a = new A();
	1. 执行静态代码块和static修饰的字段和方法
	2. 执行new，在内存中开辟空间
	3. 调用构造方法，创建一个空白对象A（所有类中都有未传值的构造方法，java会将其省略）
	4. 子类调用父类构造方法（这也是接口与类的一个区别，接口中没有构造方法，因此不能被实例化）
	5. 
~~~



### 类加载器（ClassLoader）

> 类加载器的作用就是将 .java 类文件加载成为 .class 字节码文件。本节主要内容为反射，因此本节仅简略介绍类加载器。

- 从loadClass()方法的参数中我们可以看出，我们仅需要将类名作为参数传递给类加载器，他就会帮我们把类加载
- 从loadClass()方法的访问修饰符得出，loadClass()多在被继承时被调用
- 在loadClass()方法中会调用 findLoadedClass() 和 findClass() 两个方法。前者是检查对应类是否已经被加载，后者是加载对应类。

~~~ java
public abstract ClassLoader{
    
    ...
        
	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{
        synchronized (getClassLoadingLock(name)) {
            // 首先，检查是否已经加载该类
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    // 如果尚未加载，则遵循父优先的等级加载机制（所谓双亲委派机制）
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // 模板方法模式：如果还是没有加载成功，调用findClass()
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

	// 子类应该重写该方法
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
    
    ...
    
}
~~~



> 额外知识点，ClassLoader是抽象类（其中包含抽象方法的类被称为抽象类），而抽象类是无法直接通过new来创建对象，抽象类可以通过abstract父类的引用指向子类实例（多态的向下转型）
>
> abstract A，class B；B extends A；A a = new B()

​		

- ClassLoader 中的 findClass()方法体仅抛了一个异常，所以根本就无法去加载.class文件，因此想要加载一个类的正确做法是子类重写覆盖findClass()方法，具体代码如下
- ClassLoader 中的 defineClass(name, datas, 0, datas.length) 方法，目的是根据 .class 文件的字节数组 byte[] b 造出一个对应的 Class 对象。defineClass最终会调用一个 native 方法，因此具体原理暂不明晰。

~~~ java
public TestLoad extend ClassLoader{
    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            /*自己另外写一个getClassData()
                      通过IO流从指定位置读取xxx.class文件得到字节数组*/
            byte[] datas = getClassData(name);
            if(datas == null) {
                throw new ClassNotFoundException("类没有找到：" + name);
            }
            //调用类加载器本身的defineClass()方法，由字节码得到Class对象
            return defineClass(name, datas, 0, datas.length);
        } catch (IOException e) {
            e.printStackTrace();
            throw new ClassNotFoundException("类找不到：" + name);
        }
    }	
}
~~~



​		目前关于类加载过程大致如下

![类加载图](E:\Java\GitRepository\MyNotes\img\类加载图.jpg)