## 2022/2/15

#### JUC主要包括

- 原子类（AtomicXXX）:通过CAS保证原子性
- 锁类（XXXLock）
- 线程同步类（AQS、CountDownLatch）
- 任务执行器类（Executor体系类）
- 并发集合类（ConcurrentXXX）
- 阻塞队列类（BlockingQueue）
- Future相关类
- 其他一些辅助工具类



#### AQS 

> AQS 全称 AbstractQueuedSynchronizer 译为 抽象队列同步器

在 AQS  中维护了

- 一个 state 变量：代表竞争资源的标识，当 state 变量不为 0 时，线程阻塞
- 一个 队列：存储竞争资源失败的线程的队列

我们常见的 CountDownLatch、CyclicBarrier、Semaphore、ReentrantLock 都实现了 AQS 

AQS 采用抽象模板的方式，将其实现类分成

- 独占模式：代表有 ReentrantLock，ReentrantLock.lock() 方法会使 state + 1，ReentrantLock.unlock() 方法会使 state - 1
- 共享模式：代表有 CountDownLatch，初始设置的参数既是 state 值



#### CountDownLatch & CyclicBarrier

共同点

- 都实现了 AQS，并且都为 AQS 的共享模板
- 都是通过内置一个计数器来控制共享访问

不同点

- 线程调用 CountDownLatch.await 暂停之后，在其他线程中调用 `CountDownLatch.countdown()` 方法，都会使内置的 AQS 的 state - 1， 当它其中维护的变量变为0之后，调用 CountDownLatch.await() 方法的线程会被唤醒（一次只暂停一个线程）
- 当线程每次调用 `CyclicBarrier.await()` 方法时，都会使内置 AQS 的 state - 1， 当它其中维护的变量变为0之后，调用 CyclicBarrier.await() 方法的线程就会继续运行（一次暂停多个线程）



#### 为什么 wait() 和 notify() 不在 Thread 中？

众所周知 Java 中的锁是对象级别的。wait()、notify()、notifyAll() 的作用：wait() 的作用是让当前对象中的持锁线程**释放对象锁**并进入对象的WaitSet中；notify()是随机唤醒对象WaitSet中的一个线程，让他持有锁并执行锁中代码；notifyAll() 是唤醒对象 WaitSet 中的所有线程并让他们争抢锁。他们一个个都是操作锁对象中的底层的数据结构。

因为 Java 中的锁是对象级的，Java 中的每个对象都存有一个**监视器（monitor）**，以下为 monitor 实现加锁的核心参数：

- 进入区(Entry Set)：一个新晋线程进入对锁的争抢，如果抢到了就执行线程，否则进入等待区
- 拥有者(Owner)：持锁的正在执行的线程
- 等待区(Wait Set)：调用 wait() 方法后，释放锁，进入此区域，此时区域中的线程都等待被唤醒



#### final、static、final static修饰的变量分别存放在哪？

- final 修饰的变量：存放在 方法区 中的 运行时常量池中（String 就是 final 修饰）
- static 修饰的变量：存放在 方法区 中的 静态区 ，并且跟随着类的加载而加载



#### 为什么 Java 不能多继承

Java 是一项面向对象的编程语言，其有一个叫做多态的特性，当使用多态创建一个对象实例之后，该对象实例可以访问父类的字段和方法，此时如果有多继承，并且父类有同名方法的话，程序在执行过程中的方法调用就会产生错乱 



## 2022/2/16

#### Java 对象实例的组成

> Java 对象实例存储在内存模型的堆内存之中，下面介绍其具体组成

- 实例数据：存储类及其父类实例中的属性信息（方法信息是存储于线程方法栈中的哦）
- 对齐填充： 将实例对象内存大小补齐至8字节的倍数（方便CPU高速寻址）
- 对象头：主要由**两个字（计算机术语）**组成
  - MarkWord：标记字段，用于**存储对象自身运行时的数据**，如哈希码、GC分代年龄、锁状态标志、偏向线程ID、线程持有的锁
  - KlassPointer：类型指针，是**堆中对象实例指向方法区中类元数据的一个指针**，虚拟机通过这个指针来确定对象是哪个类的实例。； 



#### synchronized的底层实现原理

当一个对象被 synchronized 修饰之后，对象实例的对象头中的 MarkWord 会指向一个 monitor 对象，monitor 对象由很多字段，实现给线程加锁的核心参数有：

- 进入区(Entry Set)：一个新晋线程进入对锁的争抢，如果抢到了就执行线程，否则进入等待区
- 拥有者(Owner)：持锁的正在执行的线程
- 等待区(Wait Set)：调用 wait() 方法后，释放锁，进入此区域，此时区域中的线程都等待被唤醒
- 计数器(count)：记录当前对象加锁的个数（和锁重入有关）

从字节码中可知同步语句块的实现使用的是**monitorenter**和**monitorexit**指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。

执行 monitorenter 指令时

- 当线程尝试获取`锁对象的持有权`，若此时 count = 0，那么该线程获取到`锁对象的持有权`，并将count + 1
- 当线程已经为锁对象的持有者，如果此时它再获取锁，若此时 count != 0 那么 count + 1，此时的操作即为锁重入
- 当前线程获取锁对象时，count != 0，此时说明锁对象此时被其他线程持有，该线程便进入阻塞状态

执行 monitorexit 指令时

- 锁对象中的 count - 1，当 count = 0，说明锁已经被释放掉了，否则说明当前锁对象仍被其他线程持有



#### CAS 的底层实现原理

> CAS 是乐观锁的实现，在多线程情况下可以减少加锁而带来的性能损耗，缺点是时间长、开销大

在 C++ 中，CAS 方法需要三个操作数——内存位置、预期原值、新值；

在 Java 中 CAS 方法需要四个参数——对象实例、字段名称、预期原值、新值；

由此可见，Java 是通过 对象实例 + 字段名称 来定位共享变量在内存中的值的

CAS 的具体实现原理就是比较共享变量在**旧的预期值**和在**此时内存中的值**，如果他们相同则返回true并且将内存中的值替换为新值，不同则返回false并且不替换内存中的值

 

#### Java 中的锁类型及锁升级过程

> 锁的升级，即是 JVM 对 cynchronized 的优化

Synchronized 的锁升级过程：无锁——>偏向锁——>轻量级锁——>锁自旋——>重量级锁

- 偏向锁：当有一个线程访问加锁区域时，锁对象的对象头中的MarkWord记录当前持锁进程ID，这种行为被称之为偏向锁
- 轻量级锁：当锁被持有时，此时有另外一个线程试图获取锁，这是锁会在处理器上空跑，直到拿到锁，这种情况就是轻量级锁。
- 锁自旋：在线程被唤醒、刚创建时没有拿到锁，便会进入自选状态，在处理器上**空跑并且轮询**
- 重量级锁：线程锁自旋的时间过长之后，便会进入阻塞状态，此时的锁就升级成为重量级锁





## 2022/2/17

#### Redis缓存与如何保证数据一致性问题

在之前的项目中，是对权限接口做的缓存，请求权限中台，将职位与员工权限数据写入缓存中并设置过期实践，此时的缓存是只读缓存，并且不涉及数据一致性的问题，因为用户的登录不存在并发的问题，系统中一个用户只能登录一次，即在另一个浏览器登陆后，当前用户就会被挤掉。项目中的实现方案是，当用户请求权限接口，先查缓存，如果缓存为空再去请求权限中台，并在此时将权限中台数据存储至缓存中。

**延迟双删**



#### 缓存穿透、缓存击穿、缓存雪崩原因及解决方案

缓存穿透

- 是什么：当查询缓存时，不存在对应 key，此时就会去数据库中查询数据，但此时若数据库中也没有查询到对应 key，此时数据库就会报错，说明系统存在安全问题，这就是缓存穿透。
- 解决方案：
  1. 对明确不正确的 key 进行拦截
  2. 使用布隆过滤器

缓存击穿

- 是什么：缓存中 key 对应的数据存在，当数据过期的时候，有大量并发请求过来，这些请求无法从缓存中拿到数据，此时就去数据库中查询数据，当请求数据量过大，可能会把数据库压垮。
- 解决方案：
  1. 将数据设为永不过期的数据
  2. 使用互斥锁，只允许一个线程去访问数据库

缓存雪崩

- 是什么：大量缓存在同一时刻过期，此时会对后端系统带来很大压力
- 解决方案：
  1. 缓存数据的过期时间进行随机设置
  2. 将热门数据设置时间长一些，冷门数据设置时间短一些

缓存击穿是一个key失效；缓存雪崩是大批量key失效的情况



## 2021/2/19

#### HashMap的扩容机制

调用put()方法时，当hashMap中的节点数量大于capacity * 负载因子，就会进行扩容

#### 红黑树的结构

根节点是黑色，叶子节点是红色，是特化的 AVL 树



## 2021/2/21

复习算法题：1两数之和、2两数相加、3无重复字符的最长子串、19删除链表的倒数第N个节点、20有效的括号

#### nginx

nginx 在项目中的主要作用就是用作作为一个反向代理服务器。

nginx在启动时会解析其配置文件，得到需要监听的ip地址和端口，当有请求传达至监听端口，nginx就会将其拦截，根据配置文件将请求进行转发



#### eureka

eureka 在项目中的主要是实现服务的注册与发现，其中的eureka-server为eureka服务器用于发现服务，eureka-client为eureka客户端用于注册服务，它保证分布式系统的可用性和分区容错性



#### redis持久化

- RDB（redis database）：将redis中某一时刻的数据持久化到磁盘中，是一种快照式的持久化方式。redis会单独创建一个子进程来持久化数据，在持久化过程中，会生成一个临时文件，当持久化结束之后，临时文件将替换之前的持久化文件。**数据容易丢失**
- AOF（append onlyfile）：这种持久化方式仅支持追加，不支持改写文件。这种持久化方式会将执行过程的**写指令记录**下来，在数据恢复时按照从前到后的顺序都执行一遍。

- I/O多路复用：用一个线程去监听多个socket连接，当连接就绪，redis线程就会发生切换



#### stream

对于stream只是了解一点，它是Collection中定义的default方法，之前只是在前辈的代码中看他用过，随后便去简单的了解了一下。就拿ArrayList举例吧，它的对象实例调用stream() 方法，集合对象便变成了流对象，此时可以对流进行操作。我只了解一些stream的最基本的方法，例如 filter() 对流中的字段进行过滤；map()获取流中的一个值的映射集合；distinct() 流中元素的去重；sorted() 对流中元素的排序；collec() 中断流操作，将流转换为集合



## 2021/2/22

复习算法题：21合并有序链表、26删除有序数组中的重复项、28实现strStr、48旋转图像、66加一、单例模式的重复运用

#### 关键字相关

static 修饰的方法与变量属于类，不能被重写

abstract 修饰的方法，就是为了被继承而被创造的，此时方法可以没有方法体

final 修饰的方法和变量，被定死，不能被修改

#### 常见排序

![sort](\img\sort.png)

#### token实现登录鉴权

用户使用用户名和密码去请求服务器，服务器对其进行校验之后会返回一个token给客户端，随后token就会被保存在浏览器的cookie中，当用户每次请求是请求头中就会携带这个token，后台服务器会解析这个token以对登录用户身份进行鉴定。

token由header、payload、signature。其中header主要存储jwt加密方式、payload是存储有效信息的地方、signature将header和payload进行base64加密并存一个盐值。



## 2022/2/23

JVM内存参数-Xmx、-Xmn、-Xms、-XXSurvivorRatio、-XXNewRatio；

类加载过程：加载、链接、初始化；

类加载器：bootstrap、extension、application；他们加载的类的作用域不同

垃圾回收器：CMS、G1、parallelGC



## 2022/2/25

- http和https的区别
- 归并排序、选择排序、插入排序、快速排序



## 2022/2/26

#### Servlet相关

> Servlet的主要功能就是处理客户端请求，将请求数据转发至对应业务逻辑代码对齐进行处理，随后业务逻辑代码将响应数据传递给Servlet并由其传递给客户端。可以将Servlet粗浅地认为是请求的代理。

- servlet的生命周期
  1. init()：初始化 servlet，创建通过反射创建Servlet对象
  2. getServletConfiguration()：读取配置文件
  3. getServletContext()：用来装载`域对象`，session、request等
  4. service()：处理请求与响应
  5. destory()：摧毁Servlet



#### JavaWeb中的I/O模型

> 不同服务之间的数据交互也被称之为I/O模型

> 主要是客户端与服务器之间的数据交互；若在操作系统层面而言的话，就是硬盘与内存之间的数据交互

![zzzzzzzasdfoinabag](\img\zzzzzzzasdfoinabag.png)

- BIO：当线程访问Socket连接时，没有获取到其想要的数据，线程就会阻塞，直到获取到Socket连接中所需要的数据。
- NIO：当线程访问Socket连接时，没有获取到其想要的数据，线程就会polling(轮询)去访问其他Socket连接，从Socket中没有获取到数据就会返回错误。这种方式虽然效率高，但是对CPU十分不友好。
- AIO：与前两者最大的不同就是，线程执行AIO时会立刻返回，此时线程就去处理别的事务，直到收到Socket发给线程的信号，此时线程就会去接收Socket发来的数据，I/O操作完成。

#### I/O多路复用

> redis中会用一个线程去监听多个socket连接，当连接就绪，redis线程就会发生切换。其核心实现时select、poll、epoll

下面的描述符的概念，可以理解为redis中的Socket连接

- select：允许应用程序监视一组`描述符`，当一个或多个`描述符`处于就绪状态，从而完成 I/O 操作。
- poll：与select类似，但是select可以修改`描述符`，而poll不可以
- epoll：会将已注册的`描述符`维护在一颗红黑树上，当通过函数**回调**内核（Socket缓存），会将红黑树中已经准备好的描述符加入到一个链表中管理



## 2022/2/27

#### 索引的分类

- 主键索引：唯一非空索引
- 唯一索引：唯一索引，可以为空值
- 组合索引：平常我们添加的索引都是组合索引，使用组合索引的时候要注意最左匹配原则
- 全文索引：仅 MyISAM 引擎支持，作用于 char、text 类型字段上

#### 索引失效条件

1. 没有遵循最左匹配原则
2. 在查询时对列进行了>、<、like、between、or、is null 等操作
3. 在查询时对列进行了运算

#### 什么样的字段要加索引

1. 经常被用于查询的字段
2. 经常需要排序的字段（hash索引不会排序）
3. 被作为两表之间连接的字段

#### MyISAM 和 InnoDB 的区别

1. 前者仅支持表级锁，后者支持行级锁
2. 前者不支持事务，后者支持
3. 前者不支持外键，后者支持
4. 前者不支持MVCC，后者支持

#### MVCC 是啥及其实现原理

> MVCC：通过对一份数据保留多个版本，从而实现并发场景下的数据读取问题
>
> undo log 链是版本控制的核心实现，read view 是解决并发场景下事务问题的核心关键

##### MVCC 的版本链的实现

- DB_ROW_ID：主键ID
- DB_ROLL_PTR：回滚指针，指向 undo log 链，undo log 链就是通过一个个版本的更新生成的
- DB_TRX_ID：事务ID

##### MVVC 版本链的生成过程

![zzzzzzzzzsodiguabnoweirj](img\zzzzzzzzzsodiguabnoweirj.png)

##### read view（即快照读）

> 事务执行过程中的快照，事务隔离级别的 read commited 和 read repeat 通过此实现

- 当事务隔离级别为 read commited 时：每当执行一次 select 操作，就会创建一个 read view，以此来保证获取到的 read view 时即时的。
- 当事务隔离级别为 read repeat 时：保留第一次执行 select 时的 read view，以此来保证事务提交时读取到的数据不变

#### bin log、redo log、undo log

- bin log：是 MySQL 级别日志，用于记录执行过程中的所有修改操作，因此 show 和 select 不做记录（用于数据的恢复）
- redo log：是 InnoDB 特有的日志，当事务开启时，所有的操作都会记录在redo log 中，就算事务没有提交，也会被记录下来（用于数据的恢复）
- undo log：是 InnoDB 特有日志，记录事物中数据被修改前的快照。当一个事务中，数据发生了修改，其被修改前的数据快照就会被记录在 undo log 中



## 2022/3/1

#### 网络协议相关

- OSI协议（从上到下）：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
- 五层协议（从上到下）：应用层、传输层、网络层、数据链路层、物理层

#### 对于各层的理解

- 应用层：此时数据已经从互联网中获取到，在网络的层次体系中，应用层仅仅负责数据的应用与展示。应用层最直观的表现就是主机上的一个进程，它通过 **DNS** 访问对应服务、并通过 **HTTP** 协议获取对应数据。
- 传输层：应用层的通信是建立再传输层之上的，应用层中从互联网中获取到的数据，都是通过传输层传递而来的，互联网的两台主机之间的数据都是通过传输层来传输的。互联网中的数据传输主要是针对于 **TCP** 和 **UDP** 两种协议实现。
- 网络层：由于互联网过于庞大，在通常情况下，互联网的两台主机中的数据并不是直接连接的，在互联网每台主机都有其 IP 地址，如果一个中国的主机要访问一台美国的主机，期间就需要经过多次的地址转换，地址转换的实现，是通过给每一个主机分配一个硬件地址，即**MAC** 地址，通过 MAC 地址，就能精确地定位到互联网中的主机。
  - MAC：IP 相当于省市区信息，MAC 相当于单元栋门号详细信息
  - ARP：地址解析协议。位于主机中，存储 IP 地址与 MAC 地址的映射
  - ICMP：网际控制报文协议。封装在 IP 数据报中，用于提高转发 IP 数据报和提高交付机会
  - VPN：虚拟专用网。连接了 VPN 就可以使用对应的服务器访问资源
  - NAT：网络地址转换。将本地 IP 转化成为全球 IP，是一种路由器
  - 路由器：
- 数据链路层：上述的网络层，只是保证了主机之间能够交换 IP 数据报，但是详尽的数据要如何交换，那还得看数据链路层。数据链路层会将网络层传递来的 IP 数据包组装成**帧**，并以此进行通信。
- 物理层：电波传递



## 2022/3/2

#### Spring为什么要把Java对象装饰成Bean对象

Spring 把 Java 对象装饰成 Bean 对象之后，就可以在不改变现有 Java对象结构的情况下，动态地对齐功能进行额外的扩展。Spring 将 Java 对象装饰成 Bean 是装饰器模式的体现。装饰器模式是对 Java 继承特性的扩展。

当我们创建一个类A定义了一些属性，此时让一个类B去继承A，此时就可以通过B去访问A中的对象，并在B中写一些方法，以达到对A扩展的目的

#### Spring事务传播

> 假设有两个方法 A、B，他们都有对数据库增删的操作。此时方法A调用了方法B，并且此时在方法A、B上使用了 @Transactional 注解，此时就会有事务的传播的情况发生

- REQUIRED（default）：如果存在外部事务，则使用该事务；否则新建一个事务并使用
- REQUIRES_NEW：不论是否存在外部事务，都新建一个事务并使用，此时外部事务挂起，新事务执行完毕之后，再执行外部事物
- SUPPORT：如果存在外部事物，就加入该事务；否则就不使用事务
- NOT_SUPPORT：如果存在外部事物，外部事物挂起；方法在不使用事务的情况下执行完毕后再启用外部事务
- MANDATORY：必须存在外部事物，并且使用该事务，否则抛出异常
- NEVER：必须没有外部事务，并且不使用事务，否则抛出异常
- NESTED：如果存在外部事务，那么方法将会在嵌套事务中运行；否则就与REQUIRED一样，新建一个事务并使用



## 2022/3/3

#### 昨日笔试题知识点

##### 算法题

- 字符串的最小前缀和
- 判断一个字符串是否为 IPV4
- 字符串中非重复元素个数

##### 数据库

- SQL 的执行顺序
  1. from 选定数据源
  2. join 选择需要连接的数据源
  3. on 选定以什么形式进行连接
  4. where 对于查询到的数据进行筛选
  5. group by 将数据分组
  6. sum、avg 等聚集函数对数据进行计算
  7. having 筛选分组
  8. 计算所有表达式 + - * / 等
  9. select 查询出筛选的结果
  10. order by 对筛选出的结果进行排序

##### 操作系统

###### 操作系统的进程是什么

​	操作系统的进程是资源分配的最小单位，一个进程代表着一个正在运行的程序实例

###### 进程间的通信方式

> 进程之间相互通信是为了：数据传输、资源共享、通知时间、进程控制

- 管道（pipe）：管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写；是一种半双工的通信方式
- 命名管道（FIFO)：去除了管道只能在父子进程中使用的限制，指定 path 即可实现进程间信息的传递
- 消息队列（MQ)：是有存储消息数据的链表，存放在内核中并由消息队列标识符标识。
- 信号量（Semaphore）：是一个计数器，可以用来控制多个进程对共享资源的访问。当线程申请操作资源时，会先读取信号量的值，若其大于0，资源可以请求；若其等于0，资源不能请求，此时进程会进入睡眠状态直至资源可用。
  - 当一个进程不在使用资源时，信号量+1，对于操作系统的 V 操作
  - 当一个进程开始使用资源时，信号量-1，对应操作系统的 P 操作
  - 临界区：一次只允许一个进程使用的资源
  - 临界资源：访问临界资源的程序代码片段
- 共享内存（shared memory）：映射一段能被其他进程所访问的内存，这段内存由一个进程创建，但多个进程都可以共享访问。
- 套接字（Socket）：

###### 死锁产生的条件

1. 互斥条件：一个资源每次只能被一个进程所使用
2. 不可剥夺条件：一个进程获取了一个资源，在此次元未使用完之前，其他进程不能剥夺此资源
3. 请求和保持条件：一个进程在请求资源时，不会释放其持有的资源
4. 循环等待条件：若干进程形成一种头尾相连接的循环等待关系；即 线程A 等待 线程B 释放资源，此时 线程B 又在等待 线程A 释放资源

###### 如何预防死锁

1. 制定资源的合理分配算法，避免进程永久占用资源
2. 防止进程在等待资源的过程中，占用资源，使其他线程无法正常运行

###### 操作系统间常见的调度方法有

- 批处理系统：没有太多的用户操作，最大程度保证吞吐量和周转时间
  1. 先来先服务（FCFS：first-come first-servered）：非抢占式调度算法，按照请求顺序进行调度
  2. 短作业优先（SJF：shortest job first）：非抢占式调度算法，按照运行时间最短的顺序进行调度
  3. 最短剩余时间优先（SRTN：shortest remaining time next）：抢占式调度算法，按照仍无剩余时间进行调度
- 交互式系统：有大量的用户交互操作，最大程度保证目标的快速响应
  1. 时间片轮转：将所有就绪进程按照 FCFS 的原则排成一个队列，每次调度时把CPU 时间分配给队首进程，该进程可以执行一个时间片，当时间片用完时，该任务终止并被送至队列末尾
  2. 优先级调度：为每个进程分配一个优先级，按照优先级进行调度
  3. 多级反馈队列：设置多个队列，**为每个队列分配不同时间片**，当任务在第一个队列执行完后，就被分配至下一个队列，如此往复



#### 今日笔试题知识点

##### 数据结构

- 拓扑排序：当图为有向无环图，该图存在拓扑排序
- Tire树：哈希树的变种，用于查找，通常用作于搜索引擎，还可以用来存储字符串前缀

##### Linux

###### Linux命令相关

- unmask ：
- chmod：
- touch：

###### linux权限相关

- ?rwx?rwx?rwx：以?分组，第一组指所有者权限；第二组指同组用户权限；第三组指其他用户权限；
  - ?：当?为不同类型时，表现不同文件类型
    - -：普通文件
    - d：文件夹（目录）
    - l：链接文件
    - b：块设备
    - c：字符设备
  - r = 4：read
  - w = 2：write
  - x = 1：excute



## 2022/3/8

##### 进程之间的通信方式（上链）

##### Redis的基本数据结构

- String：动态数组
- List：双向链表，增删块，查询慢
- Hash：数组 + 链表
- Set：相当于 HashSet
- Zset：跳跃表