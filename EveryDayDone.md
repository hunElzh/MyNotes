## 2022/2/15

#### JUC主要包括

- 原子类（AtomicXXX）:通过CAS保证原子性
- 锁类（XXXLock）
- 线程同步类（AQS、CountDownLatch）
- 任务执行器类（Executor体系类）
- 并发集合类（ConcurrentXXX）
- 阻塞队列类（BlockingQueue）
- Future相关类
- 其他一些辅助工具类



#### AQS 

> AQS 全称 AbstractQueuedSynchronizer 译为 抽象队列同步器

在 AQS  中维护了

- 一个 state 变量：代表竞争资源的标识，当 state 变量不为 0 时，线程阻塞
- 一个 队列：存储竞争资源失败的线程的队列

我们常见的 CountDownLatch、CyclicBarrier、Semaphore、ReentrantLock 都实现了 AQS 

AQS 采用抽象模板的方式，将其实现类分成

- 独占模式：代表有 ReentrantLock，ReentrantLock.lock() 方法会使 state + 1，ReentrantLock.unlock() 方法会使 state - 1
- 共享模式：代表有 CountDownLatch，初始设置的参数既是 state 值



#### CountDownLatch & CyclicBarrier

共同点

- 都实现了 AQS，并且都为 AQS 的共享模板
- 都是通过内置一个计数器来控制共享访问

不同点

- 线程调用 CountDownLatch.await 暂停之后，在其他线程中调用 `CountDownLatch.countdown()` 方法，都会使内置的 AQS 的 state - 1， 当它其中维护的变量变为0之后，调用 CountDownLatch.await() 方法的线程会被唤醒（一次只暂停一个线程）
- 当线程每次调用 `CyclicBarrier.await()` 方法时，都会使内置 AQS 的 state - 1， 当它其中维护的变量变为0之后，调用 CyclicBarrier.await() 方法的线程就会继续运行（一次暂停多个线程）



#### 为什么 wait() 和 notify() 不在 Thread 中？

总所周知 Java 中的锁是对象级别的。wait()、notify()、notifyAll() 的作用：wait() 的作用是让当前对象中的持锁线程**释放对象锁**并进入对象的WaitSet中；notify()是随机唤醒对象WaitSet中的一个线程，让他持有锁并执行锁中代码；notifyAll() 是唤醒对象 WaitSet 中的所有线程并让他们争抢锁。他们一个个都是操作锁对象中的底层的数据结构。

因为 Java 中的锁是对象级的，Java 中的每个对象都存有一个**监视器（monitor）**，以下为 monitor 实现加锁的核心参数：

- 进入区(Entry Set)：一个新晋线程进入对锁的争抢，如果抢到了就执行线程，否则进入等待区
- 拥有者(Owner)：持锁的正在执行的线程
- 等待区(Wait Set)：调用 wait() 方法后，释放锁，进入此区域，此时区域中的线程都等待被唤醒



#### final、static、final static修饰的变量分别存放在哪？

- final 修饰的变量：存放在方法区 中的 运行时常量池中
- static 修饰的变量：存放在方法区中的静态区中，并且跟随着类的加载而加载



#### 为什么 Java 不能多继承

Java 是一项面向对象的编程语言，其有一个叫做多态的特性，当使用多态创建一个对象实例之后，该对象实例可以访问父类的字段和方法，此时如果有多继承，并且父类有同名方法的话，程序在执行过程中的方法调用就会产生错乱 



## 2022/2/16

#### Java 对象实例的组成

> Java 对象实例存储在内存模型的堆内存之中，下面介绍其具体组成

- 实例数据：存储类及其父类实例中的属性信息（方法信息是存储于线程方法栈中的哦）
- 对齐填充： 将实例对象内存大小补齐至8字节的倍数（方便CPU高速寻址）
- 对象头：主要由**两个字（计算机术语）**组成
  - MarkWord：标记字段，用于**存储对象自身运行时的数据**，如哈希码、GC分代年龄、锁状态标志、偏向线程ID、线程持有的锁
  - KlassPointer：类型指针，是**堆中对象实例指向方法区中类元数据的一个指针**，虚拟机通过这个指针来确定对象是哪个类的实例。； 



#### synchronized的底层实现原理

当一个对象被 synchronized 修饰之后，对象实例的对象头中的 MarkWord 会指向一个 monitor 对象，monitor 对象由很多字段，实现给线程加锁的核心参数有：

- 进入区(Entry Set)：一个新晋线程进入对锁的争抢，如果抢到了就执行线程，否则进入等待区
- 拥有者(Owner)：持锁的正在执行的线程
- 等待区(Wait Set)：调用 wait() 方法后，释放锁，进入此区域，此时区域中的线程都等待被唤醒
- 计数器(count)：记录当前对象加锁的个数（和锁重入有关）

从字节码中可知同步语句块的实现使用的是**monitorenter**和**monitorexit**指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。

执行 monitorenter 指令时

- 当线程尝试获取`锁对象的持有权`，若此时 count = 0，那么该线程获取到`锁对象的持有权`，并将count + 1
- 当线程已经为锁对象的持有者，如果此时它再获取锁，若此时 count != 0 那么 count + 1，此时的操作即为锁重入
- 当前线程获取锁对象时，count != 0，此时说明锁对象此时被其他线程持有，该线程便进入阻塞状态

执行 monitorexit 指令时

- 锁对象中的 count - 1，当 count = 0，说明锁已经被释放掉了，否则说明当前锁对象仍被其他线程持有



#### CAS 的底层实现原理

> CAS 是乐观锁的实现，在多线程情况下可以减少加锁而带来的性能损耗，缺点是时间长、开销大

在 C++ 中，CAS 方法需要三个操作数——内存位置、预期原值、新值；

在 Java 中 CAS 方法需要四个参数——对象实例、字段名称、预期原值、新值；

由此可见，Java 是通过 对象实例 + 字段名称 来定位共享变量在内存中的值的

CAS 的具体实现原理就是比较共享变量在**旧的预期值**和在**内存中的值**，如果他们相同则返回true并且将内存中的值替换为新值，不同则返回false并且不替换内存中的值



#### Java 中的锁类型及锁升级过程

> 锁的升级，即是 JVM 对 cynchronized 的优化

Synchronized 的锁升级过程：无锁——>偏向锁——>轻量级锁——>锁自旋——>重量级锁

- 偏向锁：当有一个线程访问加锁区域时，锁对象的对象头中的MarkWord记录当前持锁进程ID，这种行为被称之为偏向锁
- 轻量级锁：当锁被持有时，此时有另外一个线程试图获取锁，这是锁会在处理器上空跑，直到拿到锁，这种情况就是轻量级锁。
- 锁自旋：在线程被唤醒、刚创建时没有拿到锁，便会进入自选状态，在处理器上**空跑并且轮询**
- 重量级锁：线程锁自旋的时间过长之后，便会进入阻塞状态，此时的锁就升级成为重量级锁





## 2022/2/17

#### Redis缓存与如何保证数据一致性问题

在之前的项目中，是对权限接口做的缓存，请求权限中台，将职位与员工权限数据写入缓存中并设置过期实践，此时的缓存是只读缓存，并且不涉及数据一致性的问题，因为用户的登录不存在并发的问题，系统中一个用户只能登录一次，即在另一个浏览器登陆后，当前用户就会被挤掉。项目中的实现方案是，当用户请求权限接口，先查缓存，如果缓存为空再去请求权限中台，并在此时将权限中台数据存储至缓存中。

**延迟双删**



#### 缓存穿透、缓存击穿、缓存雪崩原因及解决方案

缓存穿透

- 是什么：当查询缓存时，不存在对应 key，此时就会去数据库中查询数据，但此时若数据库中也没有查询到对应 key，此时数据库就会报错，说明系统存在安全问题，这就是缓存穿透。
- 解决方案：
  1. 对明确不正确的 key 进行拦截
  2. 使用布隆过滤器

缓存击穿

- 是什么：缓存中 key 对应的数据存在，当数据过期的时候，有大量并发请求过来，这些请求无法从缓存中拿到数据，此时就去数据库中查询数据，当请求数据量过大，可能会把数据库压垮。
- 解决方案：
  1. 将数据设为永不过期的数据
  2. 使用互斥锁，只允许一个线程去访问数据库

缓存雪崩

- 是什么：大量缓存在同一时刻过期，此时会对后端系统带来很大压力
- 解决方案：
  1. 缓存数据的过期时间进行随机设置
  2. 将热门数据设置时间长一些，冷门数据设置时间短一些

缓存击穿是一个key失效；缓存雪崩是大批量key失效的情况



## 2021/2/19

#### HashMap的扩容机制

调用put()方法时，当hashMap中的节点数量大于capacity * 负载因子，就会进行扩容

#### 红黑树的结构

根节点是黑色，叶子节点是红色，是特化的 AVL 树



## 2021/2/21

复习算法题：1两数之和、2两数相加、3无重复字符的最长子串、19删除链表的倒数第N个节点、20有效的括号

#### nginx

nginx 在项目中的主要作用就是用作作为一个反向代理服务器。

nginx在启动时会解析其配置文件，得到需要监听的ip地址和端口，当有请求传达至监听端口，nginx就会将其拦截，根据配置文件将请求进行转发



#### eureka

eureka 在项目中的主要是实现服务的注册与发现，其中的eureka-server为eureka服务器用于发现服务，eureka-client为eureka客户端用于注册服务，它保证分布式系统的可用性和分区容错性



#### redis持久化

- RDB（redis database）：将redis中某一时刻的数据持久化到磁盘中，是一种快照式的持久化方式。redis会单独创建一个子进程来持久化数据，在持久化过程中，会生成一个临时文件，当持久化结束之后，临时文件将替换之前的持久化文件。**数据容易丢失**
- AOF（append onlyfile）：这种持久化方式仅支持追加，不支持改写文件。这种持久化方式会将执行过程的**写指令记录**下来，在数据恢复时按照从前到后的顺序都执行一遍。

- I/O多路复用：用一个线程去监听多个socket连接，当连接就绪，redis线程就会发生切换



#### stream

对于stream只是了解一点，它是Collection中定义的default方法，之前只是在前辈的代码中看他用过，随后便去简单的了解了一下。就拿ArrayList举例吧，它的对象实例调用stream() 方法，集合对象便变成了流对象，此时可以对流进行操作。我只了解一些stream的最基本的方法，例如 filter() 对流中的字段进行过滤；map()获取流中的一个值的映射集合；distinct() 流中元素的去重；sorted() 对流中元素的排序；collec() 中断流操作，将流转换为集合



## 2021/2/22

复习算法题：21合并有序链表、26删除有序数组中的重复项、28实现strStr、48旋转图像、66加一、单例模式的重复运用

#### 关键字相关

static 修饰的方法与变量属于类，不能被重写

abstract 修饰的方法，就是为了被继承而被创造的，此时方法可以没有方法体

final 修饰的方法和变量，被定死，不能被修改

#### 常见排序

![sort](\img\sort.png)

#### token实现登录鉴权

用户使用用户名和密码去请求服务器，服务器对其进行校验之后会返回一个token给客户端，随后token就会被保存在浏览器的cookie中，当用户每次请求是请求头中就会携带这个token，后台服务器会解析这个token以对登录用户身份进行鉴定。

token由header、payload、signature。其中header主要存储jwt加密方式、payload是存储有效信息的地方、signature将header和payload进行base64加密并存一个盐值。



## 2022/2/23

JVM内存参数-Xmx、-Xmn、-Xms、-XXSurvivorRatio、-XXNewRatio；

类加载过程：加载、链接、初始化；

类加载器：bootstrap、extension、application；他们加载的类的作用域不同

垃圾回收器：CMS、G1、parallelGC



## 2022/2/25

- http和https的区别
- 归并排序、选择排序、插入排序、快速排序



## 2022/2/26

#### Servlet相关

> Servlet的主要功能就是处理客户端请求，将请求数据转发至对应业务逻辑代码对齐进行处理，随后业务逻辑代码将响应数据传递给Servlet并由其传递给客户端。可以将Servlet粗浅地认为是请求的代理。

- servlet的生命周期
  1. init()：初始化 servlet，创建通过反射创建Servlet对象
  2. getServletConfiguration()：读取配置文件
  3. getServletContext()：用来装载`域对象`，session、request等
  4. service()：处理请求与响应
  5. destory()：摧毁Servlet



#### JavaWeb中的I/O模型

> 不同服务之间的数据交互也被称之为I/O模型

> 主要是客户端与服务器之间的数据交互；若在操作系统层面而言的话，就是硬盘与内存之间的数据交互

![zzzzzzzasdfoinabag](\img\zzzzzzzasdfoinabag.png)

- BIO：当线程访问Socket连接时，没有获取到其想要的数据，线程就会阻塞，直到获取到Socket连接中所需要的数据。
- NIO：当线程访问Socket连接时，没有获取到其想要的数据，线程就会polling(轮询)去访问其他Socket连接，从Socket中没有获取到数据就会返回错误。这种方式虽然效率高，但是对CPU十分不友好。
- AIO：与前两者最大的不同就是，线程执行AIO时会立刻返回，此时线程就去处理别的事务，直到收到Socket发给线程的信号，此时线程就会去接收Socket发来的数据，I/O操作完成。

#### I/O多路复用

> redis中会用一个线程去监听多个socket连接，当连接就绪，redis线程就会发生切换。其核心实现时select、poll、epoll

下面的描述符的概念，可以理解为redis中的Socket连接

- select：允许应用程序监视一组`描述符`，当一个或多个`描述符`处于就绪状态，从而完成 I/O 操作。
- poll：与select类似，但是select可以修改`描述符`，而poll不可以
- epoll：会将已注册的`描述符`维护在一颗红黑树上，当通过函数**回调**内核（Socket缓存），会将红黑树中已经准备好的描述符加入到一个链表中管理



## 2022/2/27

#### 索引的分类

- 主键索引：唯一非空索引
- 唯一索引：唯一索引，可以为空值
- 组合索引：平常我们添加的索引都是组合索引，使用组合索引的时候要注意最左匹配原则
- 全文索引：仅 MyISAM 引擎支持，作用于 char、text 类型字段上

#### 索引失效条件

1. 没有遵循最左匹配原则
2. 在查询时对列进行了>、<、like、between、or、is null 等操作
3. 在查询时对列进行了运算

#### MyISAM 和 InnoDB 的区别

1. 前者仅支持表级锁，后者支持行级锁
2. 前者不支持事务，后者支持
3. 前者不支持外键，后者支持
4. 前者不支持MVCC，后者支持

#### MVCC 是啥及其实现原理

> MVCC：通过对一份数据保留多个版本，从而实现并发场景下的数据读取问题
>
> undo log 链是版本控制的核心实现，read view 是解决并发场景下事务问题的核心关键

##### MVCC 的版本链的实现（DB_ROW_ID、DB_ROLL_PTR、DB_TRX_ID）

- DB_ROW_ID：主键ID
- DB_ROLL_PTR：回滚指针，指向 undo log 链，undo log 链就是通过一个个版本的更新生成的
- DB_TRX_ID：事务ID

##### MVVC 版本链的生成过程

![zzzzzzzzzsodiguabnoweirj](img\zzzzzzzzzsodiguabnoweirj.png)

##### read view（一种快照读？）

> 事务执行过程中的快照，事务隔离级别的 read commited 和 read repeat 通过此实现

- 当事务隔离级别为 read commited 时：每当执行一次 select 操作，就会创建一个 read view，以此来保证获取到的 read view 时即时的。
- 当事务隔离级别为 read repeat 时：保留第一次执行 select 时的 read view，以此来保证事务提交时读取到的数据不变

#### bin log、redo log、undo log

- bin log：是 MySQL 级别日志，用于记录执行过程中的所有修改操作，因此 show 和 select 不做记录（用于数据的恢复）
- redo log：是 InnoDB 特有的日志，当事务开启时，redo log 开始记录事务中的操作，事务若没有提交，也不会被记录下来（用于数据的恢复）
- undo log：用于记录数据被修改前的内容（用于数据回滚）





















