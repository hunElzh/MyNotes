### 数据库分表

https://www.cnblogs.com/aksir/p/9085694.html

#### 为什么要分表

项目开发中，我们的数据库数据越来越大，随之而来的是单个表中数据太多。以至于查询书读变慢，而且由于表的锁机制导致应用操作也搜到严重影响，出现了数据库性能瓶颈。

当出现这种情况时，我们可以考虑分表，即将单个数据库表进行拆分，拆分成多个数据表，然后用户访问的时候，根据一定的算法，让用户访问不同的表，这样数据分散到多个数据表中，减少了单个数据表的访问压力。提升了数据库访问性能。



### 数据库的两种引擎

#### InnoDB（当前mysql版本的默认引擎）

> 适用于事务处理，具有ACID事务支持，应用于大量的 insert 和 update 操作

1. 支持事务，且事务是安全的
2. 提供**行级锁**与外键约束
3. 有缓冲池，用于缓冲数据库和索引

#### MyISAM

> 适用于管理非事务表，提供高速检索及全文检索能力，适用于有大量 select 操作的表

1. 不支持事务
2. 不支持外键约束和行级锁，操作MyISAM表时会**锁定整张表**，并保存表的行数



### MySQL的各种锁

- 从性能上分为**乐观锁**和**悲观锁**

- 从数据库操作类型分，分为**读锁**和**写锁**（这俩都是悲观锁）

  - 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响
  - 写锁（排他锁）：当写操作没有完成前，会阻断其他写锁和读锁

- 从数据操作的颗粒度，分为**行锁、页锁、表锁**

  - 行锁（偏写）

    > 行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 

  - 表锁（偏读）

    > 表锁偏向MyISAM存储引擎，开销小，加锁快，无思索，锁定粒度大，发生锁冲突的概率最高，并发度最低。 

  - 死锁

    > 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。 

    死锁的解决方法

    1.  以固定的顺序访问表和行
    2.  大事务拆小
    3.  在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率
    4.  降低隔离级别
    5.  为表添加合理的索引

    

### 存储过程和触发器

#### 存储过程（类似于函数）

> 是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。 

~~~ mysql
-- 创建格式
DELIMITER //
CREATE PROCEDURE 储存名([ IN ,OUT ,INOUT ]?参数名?数据类形...)
BEGIN
SQL语句
END //
DELIMITER ;

-- 创建实例
DELIMITER //
CREATE PROCEDURE addUser
(IN uCode VARCHAR(50),IN uName VARCHAR(20),IN uRole INT,IN sex INT,IN tel VARCHAR(30))
BEGIN
INSERT INTO smbms_user (userCode,userName,userRole,gender,phone)
VALUES(uCode,uName,uRole,sex,tel);
END//
DELIMITER //

-- 查看存储过程 
show procedure status;

-- 使用存储过程的java代码
<insert id="saveUser">
	CALL addUser(#{userCode},#{userName},#{userRole},#{gender},#{phone})
</insert>
public int saveUser(
    @Param("userCode") String userCode,
    @Param("userName") String userName,
    @Param("userRole") Integer userRole,
    @Param("gender") Integer gender,
    @Param("phone") String phone);
public List findUserListPage(
    String queryUserName,
    Integer queryUserRole,
    Integer currentPageNo, 
    Integer pageSzie);
public boolean saveUser(
    String userCode, 
    String userName,
    Integer userRole,
	Integer gender, 
    String phone) {
        SqlSession sqlSession = null;
        int row = 0; // 受影响的行数
        try {
            sqlSession = MyBatisUtil.createSqlSession();
            row = sqlSession.getMapper(UserMapper.class).saveUser(userCode, userName, userRole, gender, phone);
            // 提交事务
            sqlSession.commit();
        } catch (Exception e) {
            if (sqlSession != null) {
                sqlSession.rollback();
            }
            row = 0;
            e.printStackTrace();
        } finally {
        	MyBatisUtil.closeSqlSession(sqlSession);
        }
        if (row > 0) {
        	return true;
        }
        return false;
}

userService.saveUser("zhangcuishan", "亚索", 1, 2, "15645678941");
~~~

#### 触发器（类似于js中的事件）

> 触发器是一种特殊类型的存储过程，它又不同于存储过程，触发器主要是通过事件进行触发而被执行的，而存储过程可以通过存储过程名字而被直接调用。 

作用

	1. 在写入标签，强制检验或转换数据
 	2. 触发器发生错误时，异动的结果会被撤销

~~~ mysql
-- 创建格式
DELIMITER //
Create trigger --触发器名字 触发时机 触发事件 on 表 for each
row
Begin
--操作的内容
End //
DELIMITER ;

-- 具体实例
create table my_goods(
id int primary key auto_increment,
name varchar(20) not null,
inv int
)

create table my_orders(
id int primary key auto_increment,
goods_id int not null,
goods_num int not null)

insert into my_goods values(null,'手机',1000),(null,'电脑',500),(null,'游戏机',100);

DELIMITER //
CREATE TRIGGER a_i_o_t AFTER INSERT ON my_orders FOR EACH ROW
BEGIN
UPDATE my_goods SET inv =inv -new.goods_num WHERE id=new.goods_id;
END
//
DELIMITER ;

DELIMITER //
CREATE TRIGGER b_i_o_t BEFORE INSERT ON my_orders FOR EACH ROW
BEGIN
SELECT inv FROM my_goods WHERE id=new.goods_id INTO @inv;
IF @inv
INSERT INTO xxx VALUES('xx');
END IF;
END
//
DELIMITER //

测试 insert into my_orders values(null,3,5);
~~~



### 视图

#### 视图是什么

> 视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。就是基于一个基本表根据查询语句创建出来的一个特定的数据集

视图的优点

1. 简单： 使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 
2.  安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 
3. 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 



### 事务

#### 事务的四个属性

- 原子性（Atomicity）表示最小的执行单元，不能再切割。事务的原子性保证执行过程要么全部成功，要么全部失败。
- 一致性（Consistency）一致性是指事务将数据库从一种一致性转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏。
- 隔离性（Isolation）并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
- 持久性（Durability）一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失。

#### 并发事务带来的问题

1. 更新丢失（Lost Update）

   当两个或多个事务同时处理同一行数据，由于每个事务不知道其它事务的存在，会发生A更新一条数据后，B再更新覆盖了A的更新，这就是更新丢失。

2. 脏读（Dirty Reads）

   当事务A对一条记录正在做修改操作，此时事务B开始读取该条记录但是事务A还未提交，这个时候事务B读取到的数据就是脏数据（因为事务A回滚后，事务B读取到的时A更改但为提交的数据），这种情况被称之为脏读。

3. 不可重复读（Non-Repeatable Reads）

   事务A在一次事务中执行两次查询操作，并且查询的时同一行数据，但是两次查询的结果不同，这是因为在事务A执行过程中，事务B在表中对该数据执行了更新操作，导致事务A读取到的两次数据不同，这种情况即为不可重复读。

4. 幻读（Phantom Reads）

   在一次事务中事务A按照使用相同的查询条件重新读取之前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，此时事务A查询结果与第一次查询不同，结果多出（减少）几行。

#### 事务的隔离级别

![1631500126910](..\img\1631500126910.png)



### sql注入

> SQL注入是恶意用户通过在表单中填写包含SQL关键字的数据来使数据库执行非常规代码的过程。 
>
>  大家也许都听过某某学长通过攻击学校数据库修改自己成绩的事情，这些学长们一般用的就是SQL注入方法。 

假设在一个没有防范sql注入的系统中执行一个查询用户的操作，在对应表单中输入“lzh”即可查询“lzh”相关信息，此时将输入的“lzh”转变为“lzh); DROP TABLE xxx -- "这种情况会删除数据库中的对应表，这样会对系统造成很大危害。

### 数据表的永久性和临时性